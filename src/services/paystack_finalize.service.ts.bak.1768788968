// src/services/paystack_finalize.service.ts
import type { PoolClient } from "pg";
import { computePlatformFeeSplit } from "../config/fees.config.js";
import { setPgContext } from "../db/set_pg_context.js";
import { assertRlsContext } from "../db/rls_guard.js";

type PaystackEvent = {
  event?: string;
  data?: {
    reference?: string;
    id?: number | string;
    amount?: number; // usually minor units (kobo)
    currency?: string; // e.g. "NGN"
    status?: string;
  };
};

type PaymentRow = {
  id: string;

  // ✅ derived via join
  organization_id: string;

  tenant_id: string | null;
  listing_id: string | null;
  property_id: string | null;

  amount: string;
  currency: string | null;
  status: string | null;

  reference_type: string | null;
  reference_id: string | null;
};

function asText(v: any): string {
  return String(v ?? "").trim();
}
function asNum(v: any): number {
  return Number(v);
}
function approxEqual(a: number, b: number, eps = 0.01) {
  return Math.abs(a - b) <= eps;
}

async function ensureOrgContextMatches(client: PoolClient, orgId: string) {
  const { rows } = await client.query<{ org_id: string | null; user_id: string | null; role: string | null }>(
    `
    select
      nullif(current_setting('app.organization_id', true), '') as org_id,
      nullif(current_setting('app.user_id', true), '') as user_id,
      nullif(current_setting('app.role', true), '') as role;
    `
  );

  const curOrg = asText(rows?.[0]?.org_id);
  if (curOrg && curOrg === orgId) return;

  // keep existing user/role if set; just fix org
  const userId = asText(rows?.[0]?.user_id) || null;
  const role = asText(rows?.[0]?.role) || null;

  await setPgContext(client, { organizationId: orgId, userId, role, eventNote: "paystack:ensure_org" });
}

async function reconcilePurchaseAfterPayment(client: PoolClient, args: {
  organizationId: string;
  purchaseId: string;
  paymentId: string;
  currency: string;
  note?: string | null;
}): Promise<{ ok: true } | { ok: false; error: string; message?: string }> {
  // Lock purchase row
  const { rows } = await client.query<{
    agreed_price: string;
  }>(
    `
    select agreed_price::text as agreed_price
    from public.property_purchases
    where id = $1::uuid
      and organization_id = $2::uuid
      and deleted_at is null
    limit 1
    for update;
    `,
    [args.purchaseId, args.organizationId]
  );

  const pr = rows?.[0];
  if (!pr) return { ok: false, error: "PURCHASE_NOT_FOUND" };

  const agreed = asNum(pr.agreed_price);
  if (!Number.isFinite(agreed) || agreed <= 0) return { ok: false, error: "INVALID_PURCHASE_PRICE" };

  // Source of truth: property_purchase_payments (no deleted_at column)
  const { rows: sumRows } = await client.query<{ total_paid: string }>(
    `
    select coalesce(sum(ppp.amount), 0)::text as total_paid
    from public.property_purchase_payments ppp
    join public.payments p on p.id = ppp.payment_id
    where ppp.purchase_id = $1::uuid
      and ppp.organization_id = $2::uuid
      and p.deleted_at is null
      and p.status = 'successful'::public.payment_status;
    `,
    [args.purchaseId, args.organizationId]
  );

  const totalPaid = asNum(sumRows?.[0]?.total_paid ?? "0");
  const clampedPaid = Math.min(totalPaid, agreed);

  let nextStatus: "unpaid" | "deposit_paid" | "partially_paid" | "paid";
  if (clampedPaid <= 0) nextStatus = "unpaid";
  else if (clampedPaid >= agreed) nextStatus = "paid";
  else nextStatus = "partially_paid";

  await client.query(
    `
    update public.property_purchases
    set
      paid_at = case when $3::numeric > 0 then coalesce(paid_at, now()) else paid_at end,
      paid_amount = $3::numeric,
      payment_status = $4::purchase_payment_status,
      last_payment_id = coalesce(last_payment_id, $5::uuid),
      updated_at = now()
    where id = $1::uuid
      and organization_id = $2::uuid
      and deleted_at is null;
    `,
    [args.purchaseId, args.organizationId, clampedPaid, nextStatus, args.paymentId]
  );

  return { ok: true };
}

export async function finalizePaystackChargeSuccess(
  client: PoolClient,
  evt: PaystackEvent
): Promise<{ ok: true } | { ok: false; error: string; message?: string }> {
  if (asText(evt.event) !== "charge.success") return { ok: true };

  const reference = asText(evt.data?.reference);
  if (!reference) return { ok: false, error: "MISSING_REFERENCE" };

  // derive org via listing/property
  const payRes = await client.query<PaymentRow>(
    `
    select
      p.id::text as id,
      coalesce(pl.organization_id, pr.organization_id)::text as organization_id,

      p.tenant_id::text,
      p.listing_id::text,
      p.property_id::text,

      p.amount::text,
      p.currency,
      p.status::text,
      p.reference_type::text,
      p.reference_id::text
    from public.payments p
    left join public.property_listings pl
      on pl.id = p.listing_id
     and pl.deleted_at is null
    left join public.properties pr
      on pr.id = p.property_id
     and pr.deleted_at is null
    where p.transaction_reference = $1
      and p.deleted_at is null
    limit 1;
    `,
    [reference]
  );

  const payment = payRes.rows?.[0];
  if (!payment) return { ok: false, error: "PAYMENT_NOT_FOUND", message: `reference=${reference}` };

  const orgId = asText(payment.organization_id);
  if (!orgId) return { ok: false, error: "ORG_NOT_RESOLVED", message: `paymentId=${payment.id}` };

  await ensureOrgContextMatches(client, orgId);
  await assertRlsContext(client);

  const alreadySuccessful = asText(payment.status).toLowerCase() === "successful";
  const amountMajor = asNum(payment.amount);
  if (!Number.isFinite(amountMajor) || amountMajor <= 0) {
    return { ok: false, error: "INVALID_PAYMENT_AMOUNT", message: `payments.amount=${payment.amount}` };
  }

  const currency = asText(payment.currency) || asText(evt.data?.currency) || "USD";

  // sanity check vs paystack minor amount when provided
  const psAmount = typeof evt.data?.amount === "number" ? evt.data.amount : null;
  if (psAmount != null) {
    const major = psAmount / 100;
    const okMatch = approxEqual(amountMajor, major) || approxEqual(amountMajor, psAmount);
    if (!okMatch) {
      return {
        ok: false,
        error: "AMOUNT_MISMATCH",
        message: `payments.amount=${amountMajor} vs paystack.amount=${psAmount} (major=${major})`,
      };
    }
  }

  // -----------------------------
  // PURCHASE FLOW: escrow hold + reconcile purchase
  // -----------------------------
  if (asText(payment.reference_type) === "purchase" && asText(payment.reference_id)) {
    // ensure payment row is successful (idempotent)
    if (!alreadySuccessful) {
      await client.query(
        `
        update public.payments
        set
          status = 'successful'::public.payment_status,
          completed_at = now(),
          gateway_transaction_id = coalesce(gateway_transaction_id, $2::text),
          gateway_response = coalesce(gateway_response, $3::jsonb),
          currency = coalesce(currency, $4::text),
          updated_at = now()
        where id = $1::uuid
          and deleted_at is null;
        `,
        [payment.id, asText(evt.data?.id), JSON.stringify(evt), currency]
      );
    }

    // escrow hold: NEW TOTAL held (your function expects total)
    // If your schema uses escrow_held_amount already, it will keep increasing safely.
    const { rows: prRows } = await client.query<{ escrow_held_amount: string | null }>(
      `
      select escrow_held_amount::text as escrow_held_amount
      from public.property_purchases
      where id = $1::uuid
        and organization_id = $2::uuid
        and deleted_at is null
      limit 1
      for update;
      `,
      [payment.reference_id, orgId]
    );

    const curHeld = asNum(prRows?.[0]?.escrow_held_amount ?? "0");
    const nextHeld = curHeld + amountMajor;

    await client.query(
      `select public.purchase_escrow_hold($1::uuid, $2::uuid, $3::numeric, $4::text, $5::text);`,
      [
        payment.reference_id,
        orgId,
        nextHeld,
        currency,
        `paystack:charge.success:${reference}`,
      ]
    );

    const purchaseId = asText(payment.reference_id);
if (!purchaseId) {
  return { ok: false, error: "PURCHASE_ID_MISSING_ON_PAYMENT", message: `paymentId=${payment.id}` };
}

const rec = await reconcilePurchaseAfterPayment(client, {
  organizationId: orgId,
  purchaseId,              // ✅ now guaranteed string
  paymentId: payment.id,
  currency,
  note: `paystack:charge.success:${reference}`,
});

if (!rec.ok) return rec;
return { ok: true };
  }

  // -----------------------------
  // RENT INVOICE FLOW (splits)
  // -----------------------------
  if (asText(payment.reference_type) !== "rent_invoice" || !asText(payment.reference_id)) {
    return { ok: false, error: "UNSUPPORTED_REFERENCE_TYPE", message: `reference_type=${payment.reference_type}` };
  }

  // resolve payee for invoice
  const r = await client.query<{ payee_user_id: string | null }>(
    `
    select p.owner_id::text as payee_user_id
    from public.rent_invoices ri
    join public.properties p on p.id = ri.property_id
    where ri.id = $1::uuid
      and ri.organization_id = $2::uuid
      and ri.deleted_at is null
    limit 1;
    `,
    [payment.reference_id, orgId]
  );

  const payeeUserId = asText(r.rows?.[0]?.payee_user_id) || null;
  if (!payeeUserId) return { ok: false, error: "PAYEE_RESOLVE_FAILED" };

  const split = computePlatformFeeSplit({
    paymentKind: "rent",
    amount: amountMajor,
    currency,
  });

  if (!Number.isFinite(split.platformFee) || !Number.isFinite(split.payeeNet)) {
    return { ok: false, error: "SPLIT_CALC_FAILED" };
  }

  // insert splits idempotently
  await client.query(
    `
    insert into public.payment_splits (
      payment_id, split_type, beneficiary_kind, beneficiary_user_id, amount, currency
    )
    select
      $1::uuid,
      'platform_fee'::public.split_type,
      'platform'::public.beneficiary_kind,
      null,
      $2::numeric,
      $3::text
    where not exists (
      select 1 from public.payment_splits
      where payment_id = $1::uuid
        and split_type = 'platform_fee'::public.split_type
    );
    `,
    [payment.id, split.platformFee, currency]
  );

  await client.query(
    `
    insert into public.payment_splits (
      payment_id, split_type, beneficiary_kind, beneficiary_user_id, amount, currency
    )
    select
      $1::uuid,
      'payee'::public.split_type,
      'user'::public.beneficiary_kind,
      $2::uuid,
      $3::numeric,
      $4::text
    where not exists (
      select 1 from public.payment_splits
      where payment_id = $1::uuid
        and split_type = 'payee'::public.split_type
    );
    `,
    [payment.id, payeeUserId, split.payeeNet, currency]
  );

  // link payment -> invoice + update invoice
  await client.query(
    `
    insert into public.invoice_payments (invoice_id, payment_id, amount)
    values ($1::uuid, $2::uuid, $3::numeric)
    on conflict do nothing;
    `,
    [payment.reference_id, payment.id, amountMajor]
  );

  await client.query(
    `
    update public.rent_invoices ri
    set
      paid_amount = coalesce(ri.paid_amount, 0) + $1::numeric,
      paid_at = now(),
      status = case
        when (coalesce(ri.paid_amount, 0) + $1::numeric) >= ri.total_amount
          then 'paid'::public.invoice_status
        else ri.status
      end,
      updated_at = now()
    where ri.id = $2::uuid
      and ri.organization_id = $3::uuid
      and ri.deleted_at is null;
    `,
    [amountMajor, payment.reference_id, orgId]
  );

  // update payment last (idempotent)
  await client.query(
    `
    update public.payments
    set
      status = 'successful'::public.payment_status,
      completed_at = now(),
      gateway_transaction_id = coalesce(gateway_transaction_id, $2::text),
      gateway_response = coalesce(gateway_response, $3::jsonb),
      platform_fee_amount = $4::numeric,
      payee_amount = $5::numeric,
      currency = coalesce(currency, $6::text),
      updated_at = now()
    where id = $1::uuid
      and deleted_at is null;
    `,
    [payment.id, asText(evt.data?.id), JSON.stringify(evt), split.platformFee, split.payeeNet, currency]
  );

  return { ok: true };
}