// src/routes/webhooks.ts
import type { FastifyInstance } from "fastify";
import crypto from "node:crypto";

import { paymentConfig } from "../config/payment.config.js";
import { finalizePaystackChargeSuccess } from "../services/paystack_finalize.service.js";
import { finalizePaystackTransferEvent } from "../services/payouts.service.js";
import { setPgContext } from "../db/set_pg_context.js";

type WebhookCtx = {
  organizationId: string;
  actorUserId: string | null;
  reference: string;
};

function normalizeSig(sigHeaderRaw: string): string {
  return String(sigHeaderRaw ?? "")
    .trim()
    .toLowerCase()
    .replace(/^sha512=/i, "")
    .trim();
}

function safeTimingEqualHex(aHex: string, bHex: string): boolean {
  try {
    const a = Buffer.from(aHex, "hex");
    const b = Buffer.from(bHex, "hex");
    return a.length === b.length && crypto.timingSafeEqual(a, b);
  } catch {
    return false;
  }
}

function extractPaystackReference(event: any): string {
  return String(
    event?.data?.reference ??
      event?.data?.metadata?.reference ??
      event?.data?.metadata?.ref ??
      event?.reference ??
      ""
  ).trim();
}

function extractTransferIdentifiers(event: any): { reference: string; transferCode: string } {
  const data = event?.data ?? {};
  return {
    reference: String(data?.reference ?? "").trim(),
    transferCode: String(data?.transfer_code ?? "").trim(),
  };
}

/**
 * Payments-based context resolver (for charge.success).
 * organization_id comes from property_listings/properties via listing_id/property_id.
 */
async function resolvePaymentWebhookContext(pg: any, event: any): Promise<WebhookCtx | null> {
  const reference = extractPaystackReference(event);
  if (!reference) return null;

  const TRY_REFS = [
    "transaction_reference",
    "reference",
    "provider_reference",
    "gateway_reference",
    "paystack_reference",
    "external_reference",
  ] as const;

  const TRY_ACTORS = [
    "tenant_id",
    "created_by_user_id",
    "created_by",
    "user_id",
    "payer_id",
    "customer_id",
    "actor_user_id",
  ] as const;

  async function hasColumn(col: string): Promise<boolean> {
    const { rows } = await pg.query(
      `
      select 1
      from pg_attribute
      where attrelid = 'public.payments'::regclass
        and attname = $1
        and attisdropped = false
      limit 1;
      `,
      [col]
    );
    return !!rows?.[0];
  }

  let refCol: string | null = null;
  for (const c of TRY_REFS) {
    // eslint-disable-next-line no-await-in-loop
    if (await hasColumn(c)) {
      refCol = c;
      break;
    }
  }
  if (!refCol) return null;

  const actorCols: string[] = [];
  for (const c of TRY_ACTORS) {
    // eslint-disable-next-line no-await-in-loop
    if (await hasColumn(c)) actorCols.push(c);
  }

  const actorSelect =
    actorCols.length > 0
      ? `coalesce(${actorCols.map((c) => `p.${c}::text`).join(", ")})`
      : `null::text`;

  const { rows } = await pg.query(
    `
    select
      coalesce(pl.organization_id, pr.organization_id)::text as organization_id,
      coalesce(p.tenant_id::text, ${actorSelect}) as actor_user_id
    from public.payments p
    left join public.property_listings pl on pl.id = p.listing_id
    left join public.properties pr on pr.id = p.property_id
    where p.${refCol} = $1
    limit 1;
    `,
    [reference]
  );

  const row = rows?.[0];
  if (!row?.organization_id) return null;

  return {
    organizationId: String(row.organization_id).trim(),
    actorUserId: row.actor_user_id ? String(row.actor_user_id).trim() : null,
    reference,
  };
}

/**
 * Payouts-based context resolver (for transfer.success/failed/reversed).
 * We store reference as "payout_<uuid>" and/or gateway_payout_id == transfer_code.
 * Org comes from payouts.organization_id.
 */
async function resolveTransferWebhookContext(pg: any, event: any): Promise<WebhookCtx | null> {
  const { reference, transferCode } = extractTransferIdentifiers(event);
  const key1 = (transferCode || reference || "").trim();
  const key2 = (reference || "").trim();

  if (!key1 && !key2) return null;

  const { rows } = await pg.query(
    `
    select
      p.organization_id::text as organization_id,
      p.user_id::text as actor_user_id
    from public.payouts p
    where 1=1
      and (
        p.gateway_payout_id = $1::text
        or p.gateway_payout_id = $2::text
        or ('payout_' || p.id::text) = $2::text
      )
    limit 1;
    `,
    [key1, key2 || key1]
  );

  const row = rows?.[0];
  if (!row?.organization_id) return null;

  return {
    organizationId: String(row.organization_id).trim(),
    actorUserId: row.actor_user_id ? String(row.actor_user_id).trim() : null,
    reference: key2 || key1,
  };
}

function getRawBodyBuffer(request: any, bodyObj: any): { rawBuf: Buffer | null; bodyBuf: Buffer } {
  const rawAny = request?.rawBody as Buffer | string | undefined;

  let rawBuf: Buffer | null = null;
  if (Buffer.isBuffer(rawAny)) rawBuf = rawAny;
  else if (typeof rawAny === "string") rawBuf = Buffer.from(rawAny, "utf8");

  const bodyString = JSON.stringify(bodyObj ?? {});
  const bodyBuf = Buffer.from(bodyString, "utf8");

  return { rawBuf, bodyBuf };
}

export async function webhooksRoutes(app: FastifyInstance) {
  app.post(
    "/webhooks/paystack",
    { config: { rawBody: true } },
    async (request, reply) => {
      const secret = String(paymentConfig.paystack.webhookSecret ?? "").trim();
      if (!secret) return reply.code(500).send({ ok: false, error: "WEBHOOK_SECRET_MISSING" });

      const sigHeaderRaw = String(request.headers["x-paystack-signature"] ?? "").trim();
      if (!sigHeaderRaw) return reply.code(400).send({ ok: false, error: "SIGNATURE_MISSING" });

      const signature = normalizeSig(sigHeaderRaw);
      if (!/^[0-9a-f]{128}$/.test(signature)) {
        return reply.code(400).send({ ok: false, error: "SIGNATURE_INVALID_FORMAT" });
      }

      const bodyObj: any = (request as any).body ?? {};
      const { rawBuf, bodyBuf } = getRawBodyBuffer(request, bodyObj);

      const bytesToHash = rawBuf && rawBuf.length > 0 ? rawBuf : bodyBuf;

      const expectedHex = crypto
        .createHmac("sha512", secret)
        .update(bytesToHash)
        .digest("hex")
        .toLowerCase();

      const ok = safeTimingEqualHex(signature, expectedHex);

      if (!ok) {
        const debug = {
          secretLen: secret.length,
          secretPrefix: secret.slice(0, 6),
          secretSuffix: secret.slice(-4),

          signaturePrefix: signature.slice(0, 16),
          signatureSuffix: signature.slice(-16),

          expectedPrefix: expectedHex.slice(0, 16),
          expectedSuffix: expectedHex.slice(-16),

          usedRawBody: !!(rawBuf && rawBuf.length > 0),
          rawBodyType:
            (request as any).rawBody == null
              ? null
              : Buffer.isBuffer((request as any).rawBody)
              ? "buffer"
              : typeof (request as any).rawBody,
          rawLen: rawBuf ? rawBuf.length : 0,
          bodyBufLen: bodyBuf.length,
        };

        app.log.warn(debug, "paystack signature mismatch");

        const isProd = String(process.env.NODE_ENV || "").toLowerCase() === "production";
        return reply
          .code(401)
          .send(isProd ? { ok: false, error: "INVALID_SIGNATURE" } : { ok: false, error: "INVALID_SIGNATURE", debug });
      }

      const event = bodyObj;
      const eventName = String(event?.event ?? "").trim();

      app.log.info({ event: eventName, ref: extractPaystackReference(event) }, "paystack webhook received");

      // @ts-ignore
      const pg = await app.pg.connect();
      try {
        await pg.query("BEGIN");
        await pg.query("SET LOCAL TIME ZONE 'UTC'");

        const systemActor = String(process.env.WEBHOOK_ACTOR_USER_ID ?? "").trim();
        if (!systemActor) {
          await pg.query("ROLLBACK");
          return reply.code(500).send({ ok: false, error: "WEBHOOK_ACTOR_USER_ID_MISSING" });
        }

        await setPgContext(pg, {
          userId: systemActor,
          organizationId: "00000000-0000-0000-0000-000000000000",
          role: "admin",
          eventNote: "paystack:webhook:pre-resolve",
        });

        let ctx: WebhookCtx | null = null;

        if (eventName === "charge.success") {
          ctx = await resolvePaymentWebhookContext(pg, event);
        } else if (eventName === "transfer.success" || eventName === "transfer.failed" || eventName === "transfer.reversed") {
          ctx = await resolveTransferWebhookContext(pg, event);
        } else {
          await pg.query("COMMIT");
          return reply.send({ ok: true });
        }

        if (!ctx?.organizationId) {
          app.log.warn({ event: eventName, ref: extractPaystackReference(event) }, "webhook ctx not resolved — skipping");
          await pg.query("COMMIT");
          return reply.send({ ok: true });
        }

        await setPgContext(pg, {
          userId: systemActor,
          organizationId: ctx.organizationId,
          role: "admin",
          eventNote: `paystack:${eventName}:${ctx.reference}`,
        });

        if (eventName === "charge.success") {
          const res = await finalizePaystackChargeSuccess(pg, event);

          if (!res.ok) app.log.warn(res, "paystack finalize result");
          else app.log.info({ reference: extractPaystackReference(event) }, "paystack finalize ok");
          if (!res.ok) {
            app.log.warn(
              { error: res.error, message: res.message, reference: ctx.reference, orgId: ctx.organizationId },
              "paystack charge finalize failed"
            );
          }
        } else {
          // ✅ IMPORTANT: payouts.service.ts expects (client, {organizationId, event})
          const res = await finalizePaystackTransferEvent(pg, {
            organizationId: ctx.organizationId,
            actorUserId: systemActor,
            event,
          });

          if (!res.ok) {
            app.log.warn({ error: res.error, reference: ctx.reference, orgId: ctx.organizationId }, "paystack transfer finalize failed");
          }
        }

        await pg.query("COMMIT");
      } catch (e) {
        try { await pg.query("ROLLBACK"); } catch {}
        app.log.error(e, "paystack webhook handler failed");
      } finally {
        pg.release();
      }

      return reply.send({ ok: true });
    }
  );
}