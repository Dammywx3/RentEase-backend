import type { FastifyInstance } from "fastify";
import { pool } from "../db/pool.js";
import { payPropertyPurchase } from "../services/purchase_payments.service.js";
import { refundPropertyPurchase } from "../services/purchase_refunds.service.js";

/**
 * Purchases Routes (BUY FLOW)
 * POST /purchases/:purchaseId/pay
 *
 * Expects:
 *  - header: x-organization-id
 *  - body: { paymentMethod: "card"|"bank_transfer"|"wallet", amount?: number }
 */
export default async function purchasesRoutes(fastify: FastifyInstance) {

  // ------------------------------------------------------------
  // POST /purchases/:purchaseId/pay
  // ------------------------------------------------------------

  

  // ------------------------------------------------------------
  // POST /purchases/:purchaseId/refund
  // ------------------------------------------------------------
  fastify.post<{
    Params: { purchaseId: string };
    Body: { refundMethod: "card" | "bank_transfer" | "wallet"; amount?: number };
  }>("/purchases/:purchaseId/refund", async (request, reply) => {
    const orgId = String(request.headers["x-organization-id"] || "");
    if (!orgId) {
      return reply.code(400).send({ ok: false, error: "ORG_REQUIRED", message: "x-organization-id required" });
    }

    const { purchaseId } = request.params;
    const refundMethod = request.body?.refundMethod;
    const amount = request.body?.amount;

    if (!refundMethod) {
      return reply.code(400).send({ ok: false, error: "REFUND_METHOD_REQUIRED", message: "refundMethod is required" });
    }

    const client = await fastify.pg.connect();
    try {
      const result = await refundPropertyPurchase(client, {
        organizationId: orgId,
        purchaseId,
        refundMethod,
        amount,
      });

      return reply.send({ ok: true, data: result });
    } catch (err: any) {
      const msg = err?.message || "Refund failed";
      const code = err?.code || "REFUND_FAILED";
      return reply.code(400).send({ ok: false, error: code, message: msg });
    } finally {
      client.release();
    }
  });


fastify.post<{
    Params: { purchaseId: string };
    Body: { paymentMethod: "card" | "bank_transfer" | "wallet"; amount?: number };
  }>("/purchases/:purchaseId/pay", async (request, reply) => {
    const orgId = String(request.headers["x-organization-id"] || "");
    if (!orgId) {
      return reply.code(400).send({ ok: false, error: "ORG_REQUIRED", message: "x-organization-id required" });
    }

    const { purchaseId } = request.params;
    const paymentMethod = request.body?.paymentMethod;
    const amount = request.body?.amount;

    if (!paymentMethod) {
      return reply.code(400).send({ ok: false, error: "PAYMENT_METHOD_REQUIRED", message: "paymentMethod required" });
    }

    const client = await fastify.pg.connect();
    try {
      const result = await payPropertyPurchase(client, {
        organizationId: orgId,
        purchaseId,
        paymentMethod,
        amount: typeof amount === "number" ? amount : null,
      });

      return reply.send({ ok: true, data: result });
    } finally {
      client.release();
    }
  });

  fastify.get("/purchases", async (request, reply) => {
    const orgId = String(request.headers["x-organization-id"] || "");
    if (!orgId) {
      return reply.code(400).send({ ok: false, error: "ORG_REQUIRED", message: "x-organization-id required" });
    }

    const client = await fastify.pg.connect();
    try {
      const { rows } = await client.query(
        `
        select
          pp.id,
          pp.organization_id,
          pp.property_id,
          pp.listing_id,
          pp.buyer_id,
          pp.seller_id,
          pp.agreed_price::text as agreed_price,
          pp.currency,
          pp.status::text as status,
          pp.payment_status::text as payment_status,
          pp.paid_at::text as paid_at,
          pp.paid_amount::text as paid_amount,
          pp.created_at::text as created_at,
          pp.updated_at::text as updated_at,

          exists (
            select 1 from public.property_purchase_payments ppp
            where ppp.purchase_id = pp.id
          ) as has_payment_link,

          (
            select count(*)
            from public.wallet_transactions wt
            where wt.reference_type='purchase'
              and wt.reference_id=pp.id
              and wt.txn_type in ('credit_payee'::wallet_transaction_type,'credit_platform_fee'::wallet_transaction_type)
          ) as ledger_txn_count
        from public.property_purchases pp
        where pp.organization_id = $1::uuid
          and pp.deleted_at is null
        order by pp.created_at desc
        limit 50;
        `,
        [orgId]
      );

      return reply.send({ ok: true, data: rows });
    } finally {
      client.release();
    }
  });

  // ------------------------------------------------------------
  // GET /purchases/:purchaseId (detail)
  // ------------------------------------------------------------
  fastify.get<{ Params: { purchaseId: string } }>("/purchases/:purchaseId", async (request, reply) => {
    const orgId = String(request.headers["x-organization-id"] || "");
    if (!orgId) {
      return reply.code(400).send({ ok: false, error: "ORG_REQUIRED", message: "x-organization-id required" });
    }

    const { purchaseId } = request.params;

    const client = await fastify.pg.connect();
    try {
      const { rows } = await client.query(
        `
        select
          pp.*,
          pp.status::text as status_text,
          pp.payment_status::text as payment_status_text,

          coalesce((
            select jsonb_agg(jsonb_build_object(
              'payment_id', p.id,
              'amount', p.amount,
              'currency', p.currency,
              'status', p.status::text,
              'transaction_reference', p.transaction_reference,
              'created_at', p.created_at
            ) order by p.created_at desc)
            from public.property_purchase_payments link
            join public.payments p on p.id = link.payment_id
            where link.purchase_id = pp.id
          ), '[]'::jsonb) as payments,

          coalesce((
            select jsonb_agg(jsonb_build_object(
              'txn_type', wt.txn_type::text,
              'amount', wt.amount,
              'currency', wt.currency,
              'created_at', wt.created_at
            ) order by wt.created_at asc)
            from public.wallet_transactions wt
            where wt.reference_type='purchase'
              and wt.reference_id=pp.id
          ), '[]'::jsonb) as ledger
        from public.property_purchases pp
        where pp.id = $1::uuid
          and pp.organization_id = $2::uuid
          and pp.deleted_at is null
        limit 1;
        `,
        [purchaseId, orgId]
      );

      const row = rows[0];
      if (!row) return reply.code(404).send({ ok: false, error: "NOT_FOUND", message: "Purchase not found" });

      return reply.send({ ok: true, data: row });
    } finally {
      client.release();
    }
  });

("/purchases/:purchaseId/pay", async (request, reply) => {
    const purchaseId = request.params.purchaseId;

    const orgHeader =
      (request.headers["x-organization-id"] as string | undefined) ||
      (request.headers["x-organizationid"] as string | undefined);

    if (!orgHeader) {
      return reply.code(400).send({
        ok: false,
        error: "MISSING_ORGANIZATION_ID",
        message: "Missing header: x-organization-id",
      });
    }

    const paymentMethod = request.body?.paymentMethod;
    const amount = request.body?.amount ?? null;

    const client = await pool.connect();
    try {
      await client.query("BEGIN");

      const result = await payPropertyPurchase(client, {
        organizationId: orgHeader,
        purchaseId,
        paymentMethod,
        amount: typeof amount === "number" ? amount : undefined,
      });

      await client.query("COMMIT");
      return reply.send({ ok: true, data: result });
    } catch (err) {
      try { await client.query("ROLLBACK"); } catch {}
      throw err;
    } finally {
      client.release();
    }
  });
}
