import type { PoolClient } from "pg";
import { ensureWalletAccount } from "../utils/wallets.js";

/**
 * Find oldest platform wallet for org (you currently have 2; we pick earliest).
 */
export async function getPlatformWalletId(
  client: PoolClient,
  organizationId: string
): Promise<string | null> {
  const { rows } = await client.query<{ id: string }>(
    `
    SELECT id
    FROM public.wallet_accounts
    WHERE organization_id = $1::uuid
      AND is_platform_wallet = true
    ORDER BY created_at ASC
    LIMIT 1;
    `,
    [organizationId]
  );
  return rows[0]?.id ?? null;
}

/**
 * Credit platform fee into platform wallet.
 * Uses txn_type = credit_platform_fee.
 */
export async function creditPlatformFee(
  client: PoolClient,
  args: {
    organizationId: string;
    referenceType: "rent_invoice" | "payment" | "purchase" | "subscription";
    referenceId: string;
    amount: number;
    currency: string;
    note: string;
  }
) {
  if (!args.amount || args.amount <= 0) return;

  const platformWalletId = await getPlatformWalletId(client, args.organizationId);
  if (!platformWalletId) return;

  await client.query(
    `
    INSERT INTO public.wallet_transactions (
      organization_id,
      wallet_account_id,
      txn_type,
      reference_type,
      reference_id,
      amount,
      currency,
      note
    )
    VALUES (
      $1::uuid,
      $2::uuid,
      'credit_platform_fee'::wallet_transaction_type,
      $3::text,
      $4::uuid,
      $5::numeric,
      $6::text,
      $7::text
    )
    ON CONFLICT DO NOTHING;
    `,
    [
      args.organizationId,
      platformWalletId,
      args.referenceType,
      args.referenceId,
      args.amount,
      args.currency,
      args.note,
    ]
  );
}

/**
 * Credit payee (landlord) wallet.
 * Uses txn_type = credit_payee.
 */
export async function creditPayee(
  client: PoolClient,
  args: {
    organizationId: string;
    payeeUserId: string;
    referenceType: "rent_invoice" | "payment" | "purchase" | "subscription";
    referenceId: string;
    amount: number;
    currency: string;
    note: string;
  }
) {
  if (!args.amount || args.amount <= 0) return;

  const payeeWalletId = await ensureWalletAccount(client, {
    organizationId: args.organizationId,
    userId: args.payeeUserId,
    currency: args.currency,
    isPlatformWallet: false,
  });

  await client.query(
    `
    INSERT INTO public.wallet_transactions (
      organization_id,
      wallet_account_id,
      txn_type,
      reference_type,
      reference_id,
      amount,
      currency,
      note
    )
    VALUES (
      $1::uuid,
      $2::uuid,
      'credit_payee'::wallet_transaction_type,
      $3::text,
      $4::uuid,
      $5::numeric,
      $6::text,
      $7::text
    )
    ON CONFLICT DO NOTHING;
    `,
    [
      args.organizationId,
      payeeWalletId,
      args.referenceType,
      args.referenceId,
      args.amount,
      args.currency,
      args.note,
    ]
  );
}

/**
 * Refund / reversal helpers
 * These mirror creditPayee / creditPlatformFee but write debit_* txn types.
 * Assumes wallet_transaction_type enum includes debit_payee and debit_platform_fee.
 */

export async function debitPayee(
  client: import("pg").PoolClient,
  args: {
    organizationId: string;
    payeeUserId: string;
    referenceType: string; // 'purchase'
    referenceId: string;   // purchase_id
    amount: number;
    currency?: string;
    note?: string;
  }
) {
  if (!args.amount || Number(args.amount) <= 0) return;

  // Reuse the same wallet lookup logic you already use in creditPayee
  // by calling creditPayee's internal helpers if you have them;
  // otherwise we follow the same signature pattern and insert a txn with txn_type='debit_payee'.
  //
  // IMPORTANT: This assumes your ledger.service has a lower-level "createWalletTransaction"
  // or similar used by creditPayee/creditPlatformFee.
  //
  // If your ledger.service doesn't expose that helper, this block must be adapted.
  //
  // We try to detect a common helper name. If not found, we throw a clear error.

  const anyLedger: any = await import("./ledger.service.js");
  const createFn =
    anyLedger.createWalletTransaction ||
    anyLedger.insertWalletTransaction ||
    anyLedger.createTransaction;

  if (!createFn) {
    throw new Error(
      "ledger.service.ts: expected a helper like createWalletTransaction/insertWalletTransaction/createTransaction (used by creditPayee). Please expose it or adapt debitPayee()."
    );
  }

  // Find payee wallet account the same way creditPayee would.
  // We assume you already have a helper getOrCreateUserWalletAccount / getUserWalletAccount etc.
  const getWalletFn =
    anyLedger.getOrCreateUserWalletAccount ||
    anyLedger.getOrCreateWalletAccount ||
    anyLedger.getUserWalletAccount;

  if (!getWalletFn) {
    throw new Error(
      "ledger.service.ts: expected a helper like getOrCreateUserWalletAccount/getOrCreateWalletAccount/getUserWalletAccount. Please expose it or adapt debitPayee()."
    );
  }

  const wa = await getWalletFn(client, {
    organizationId: args.organizationId,
    userId: args.payeeUserId,
  });

  await createFn(client, {
    organizationId: args.organizationId,
    walletAccountId: wa.id,
    txnType: "debit_payee",
    referenceType: args.referenceType,
    referenceId: args.referenceId,
    amount: Number(args.amount),
    currency: args.currency || "USD",
    note: args.note || null,
  });
}

export async function debitPlatformFee(
  client: import("pg").PoolClient,
  args: {
    organizationId: string;
    referenceType: string; // 'purchase'
    referenceId: string;   // purchase_id
    amount: number;
    currency?: string;
    note?: string;
  }
) {
  if (!args.amount || Number(args.amount) <= 0) return;

  const anyLedger: any = await import("./ledger.service.js");
  const createFn =
    anyLedger.createWalletTransaction ||
    anyLedger.insertWalletTransaction ||
    anyLedger.createTransaction;

  if (!createFn) {
    throw new Error(
      "ledger.service.ts: expected a helper like createWalletTransaction/insertWalletTransaction/createTransaction (used by creditPlatformFee). Please expose it or adapt debitPlatformFee()."
    );
  }

  const getPlatformFn =
    anyLedger.getOrCreatePlatformWalletAccount ||
    anyLedger.getPlatformWalletAccount;

  if (!getPlatformFn) {
    throw new Error(
      "ledger.service.ts: expected a helper like getOrCreatePlatformWalletAccount/getPlatformWalletAccount. Please expose it or adapt debitPlatformFee()."
    );
  }

  const wa = await getPlatformFn(client, {
    organizationId: args.organizationId,
  });

  await createFn(client, {
    organizationId: args.organizationId,
    walletAccountId: wa.id,
    txnType: "debit_platform_fee",
    referenceType: args.referenceType,
    referenceId: args.referenceId,
    amount: Number(args.amount),
    currency: args.currency || "USD",
    note: args.note || null,
  });
}

// ============================================================
// Generic wallet transaction helper (shared by credit + debit)
// ============================================================

export async function createWalletTransaction(
  client: any,
  args: {
    organizationId: string;
    walletAccountId: string;
    txnType: string; // wallet_transaction_type enum label
    amount: number;
    currency: string;
    referenceType: string;
    referenceId: string;
    note?: string | null;
  }
) {
  const {
    organizationId,
    walletAccountId,
    txnType,
    amount,
    currency,
    referenceType,
    referenceId,
    note,
  } = args;

  // If you have a unique constraint for idempotency, ON CONFLICT DO NOTHING will work great.
  // If you don't, this still works, just without strong idempotency.
  const { rows } = await client.query(
    `
    INSERT INTO public.wallet_transactions (
      id,
      organization_id,
      wallet_account_id,
      txn_type,
      amount,
      currency,
      reference_type,
      reference_id,
      note,
      created_at
    )
    VALUES (
      rentease_uuid(),
      $1::uuid,
      $2::uuid,
      $3::wallet_transaction_type,
      $4::numeric,
      $5::varchar,
      $6::varchar,
      $7::uuid,
      $8::text,
      NOW()
    )
    ON CONFLICT DO NOTHING
    RETURNING id;
    `,
    [
      organizationId,
      walletAccountId,
      txnType,
      amount,
      currency,
      referenceType,
      referenceId,
      note ?? null,
    ]
  );

  return rows?.[0]?.id ?? null;
}

// Aliases (some code/scripts may expect one of these names)
export const insertWalletTransaction = createWalletTransaction;
export const createTransaction = createWalletTransaction;

// ============================================================
// Refund / reversal helpers
// ============================================================

async function getPlatformWalletAccountId(client: any, organizationId: string): Promise<string> {
  const { rows } = await client.query(
    `
    SELECT id
    FROM public.wallet_accounts
    WHERE organization_id = $1::uuid
      AND is_platform_wallet = true
      AND deleted_at IS NULL
    ORDER BY created_at ASC
    LIMIT 1;
    `,
    [organizationId]
  );
  const id = rows?.[0]?.id;
  if (!id) {
    const e: any = new Error("Platform wallet not found");
    e.code = "PLATFORM_WALLET_NOT_FOUND";
    throw e;
  }
  return id;
}

async function getUserWalletAccountId(client: any, organizationId: string, userId: string): Promise<string> {
  const { rows } = await client.query(
    `
    SELECT id
    FROM public.wallet_accounts
    WHERE organization_id = $1::uuid
      AND user_id = $2::uuid
      AND is_platform_wallet = false
      AND deleted_at IS NULL
    ORDER BY created_at ASC
    LIMIT 1;
    `,
    [organizationId, userId]
  );
  const id = rows?.[0]?.id;
  if (!id) {
    const e: any = new Error("User wallet not found");
    e.code = "USER_WALLET_NOT_FOUND";
    throw e;
  }
  return id;
}

export async function debitPlatformFee(
  client: any,
  args: {
    organizationId: string;
    referenceType: string;
    referenceId: string;
    amount: number;
    currency: string;
    note?: string | null;
  }
) {
  const walletAccountId = await getPlatformWalletAccountId(client, args.organizationId);
  return createWalletTransaction(client, {
    organizationId: args.organizationId,
    walletAccountId,
    txnType: "debit_platform_fee",
    amount: args.amount,
    currency: args.currency,
    referenceType: args.referenceType,
    referenceId: args.referenceId,
    note: args.note ?? null,
  });
}

export async function debitPayee(
  client: any,
  args: {
    organizationId: string;
    payeeUserId: string;
    referenceType: string;
    referenceId: string;
    amount: number;
    currency: string;
    note?: string | null;
  }
) {
  const walletAccountId = await getUserWalletAccountId(client, args.organizationId, args.payeeUserId);
  return createWalletTransaction(client, {
    organizationId: args.organizationId,
    walletAccountId,
    txnType: "debit_payee",
    amount: args.amount,
    currency: args.currency,
    referenceType: args.referenceType,
    referenceId: args.referenceId,
    note: args.note ?? null,
  });
}
