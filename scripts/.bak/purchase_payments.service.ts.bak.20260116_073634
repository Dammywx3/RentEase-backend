import type { PoolClient } from "pg";
import crypto from "crypto";

import { computePlatformFeeSplit } from "../config/fees.config.js";
import { creditPayee, creditPlatformFee } from "./ledger.service.js";

/**
 * BUY FLOW PAYMENT SERVICE
 *
 * Schema notes (based on your DB):
 * - public.payments requires: tenant_id, listing_id, property_id, amount, transaction_reference, payment_method
 *   => We store buyer_id in tenant_id (because it's required and currently named tenant_id).
 * - For buy flow, DO NOT use invoice_payments (rent-only). Use:
 *   public.property_purchase_payments (purchase_id <-> payment_id)
 * - Splits:
 *   public.payment_splits supports beneficiary_kind (platform/user) + split_type (platform_fee/payee/etc)
 * - Ledger:
 *   public.wallet_transactions supports txn_type='credit_platform_fee' and 'credit_payee'
 */

type PurchaseMini = {
  id: string;
  organization_id: string;
  buyer_id: string;
  seller_id: string;
  property_id: string;
  listing_id: string | null;
  agreed_price: string;
  currency: string | null;
  status: string;
};

async function resolvePurchaseOrThrow(
  client: PoolClient,
  args: { purchaseId: string; organizationId: string }
): Promise<PurchaseMini> {
  const r = await client.query<PurchaseMini>(
    `
    SELECT
      pp.id,
      pp.organization_id,
      pp.buyer_id,
      pp.seller_id,
      pp.property_id,
      pp.listing_id,
      pp.agreed_price::text AS agreed_price,
      pp.currency,
      pp.status::text AS status
    FROM public.property_purchases pp
    WHERE pp.id = $1::uuid
      AND pp.organization_id = $2::uuid
      AND pp.deleted_at IS NULL
    LIMIT 1;
    `,
    [args.purchaseId, args.organizationId]
  );

  const p = r.rows[0];
  if (!p) {
    const e: any = new Error("Purchase not found");
    e.code = "PURCHASE_NOT_FOUND";
    throw e;
  }
  return p;
}

/**
 * payments.listing_id is NOT NULL in your schema.
 * If purchase.listing_id is null, we auto-pick an active listing for that property.
 */
async function resolveListingIdForPayment(
  client: PoolClient,
  purchase: PurchaseMini
): Promise<string> {
  if (purchase.listing_id) return purchase.listing_id;

  const r = await client.query<{ id: string }>(
    `
    SELECT id
    FROM public.property_listings
    WHERE property_id = $1::uuid
      AND deleted_at IS NULL
      AND status = 'active'::listing_status
    ORDER BY created_at DESC
    LIMIT 1;
    `,
    [purchase.property_id]
  );

  const listingId = r.rows[0]?.id;
  if (!listingId) {
    const e: any = new Error(
      "Cannot resolve listing_id for payments insert. Purchase has no listing_id and property has no active listing."
    );
    e.code = "LISTING_NOT_FOUND_FOR_PURCHASE_PAYMENT";
    throw e;
  }
  return listingId;
}

function round2(n: number): number {
  return Math.round(n * 100) / 100;
}

export async function payPropertyPurchase(
  client: PoolClient,
  args: {
    organizationId: string;
    purchaseId: string;

    /**
     * If omitted, defaults to purchase.agreed_price.
     * You can use this for deposit/partial payments later.
     */
    amount?: number | null;

    paymentMethod: "card" | "bank_transfer" | "wallet";
    currency?: string | null;

    /**
     * Optional info
     */
    note?: string | null;
  }
): Promise<{
  purchaseId: string;
  paymentId: string;
  platformFee: number;
  payeeNet: number;
  currency: string;
}> {
  // Load purchase
  const purchase = await resolvePurchaseOrThrow(client, {
    purchaseId: args.purchaseId,
    organizationId: args.organizationId,
  });

  const currency = (args.currency ?? purchase.currency ?? "USD") || "USD";
  const agreed = Number(purchase.agreed_price);
  const amount = typeof args.amount === "number" ? args.amount : agreed;

  if (!(amount > 0)) {
    const e: any = new Error("amount must be > 0");
    e.code = "INVALID_AMOUNT";
    throw e;
  }

  // Fee split (2.5% by your config)
  const split = computePlatformFeeSplit({
    paymentKind: "buy",
    amount,
    currency,
  });

  const platformFee = round2(split.platformFee);
  const payeeNet = round2(split.payeeNet);

  // Resolve listing id needed by payments table
  const listingId = await resolveListingIdForPayment(client, purchase);

  // Create payments row (we store buyer_id into tenant_id because your schema requires tenant_id)
  const transactionRef = `PUR-${purchase.id}-${crypto.randomUUID()}`.slice(0, 100);

  const payRes = await client.query<{ id: string }>(
    `
    INSERT INTO public.payments (
      tenant_id,
      listing_id,
      property_id,
      amount,
      currency,
      status,
      transaction_reference,
      payment_method,
      platform_fee_amount,
      payee_amount,
      initiated_at,
      completed_at
    )
    VALUES (
      $1::uuid,
      $2::uuid,
      $3::uuid,
      $4::numeric,
      $5::varchar(3),
      'successful'::payment_status,
      $6::varchar(100),
      $7::payment_method,
      $8::numeric,
      $9::numeric,
      NOW(),
      NOW()
    )
    RETURNING id;
    `,
    [
      purchase.buyer_id,
      listingId,
      purchase.property_id,
      amount,
      currency,
      transactionRef,
      args.paymentMethod,
      platformFee,
      payeeNet,
    ]
  );

  const paymentId = payRes.rows[0]?.id;
  if (!paymentId) {
    const e: any = new Error("Failed to create payments row");
    e.code = "PAYMENT_CREATE_FAILED";
    throw e;
  }

  // Link payment -> purchase (buy flow)
  await client.query(
    `
    INSERT INTO public.property_purchase_payments (
      organization_id,
      purchase_id,
      payment_id,
      amount
    )
    VALUES ($1::uuid, $2::uuid, $3::uuid, $4::numeric)
    ON CONFLICT DO NOTHING;
    `,
    [purchase.organization_id, purchase.id, paymentId, amount]
  );

  // Insert payment_splits (platform fee + payee)
  // Note: split_type enum values: payee, agent_markup, agent_commission, platform_fee
  // beneficiary_kind: user/platform
  if (platformFee > 0) {
    await client.query(
      `
      INSERT INTO public.payment_splits (
        payment_id,
        split_type,
        beneficiary_kind,
        beneficiary_user_id,
        amount,
        currency
      )
      VALUES (
        $1::uuid,
        'platform_fee'::split_type,
        'platform'::beneficiary_kind,
        NULL,
        $2::numeric,
        $3::varchar(3)
      );
      `,
      [paymentId, platformFee, currency]
    );
  }

  await client.query(
    `
    INSERT INTO public.payment_splits (
      payment_id,
      split_type,
      beneficiary_kind,
      beneficiary_user_id,
      amount,
      currency
    )
    VALUES (
      $1::uuid,
      'payee'::split_type,
      'user'::beneficiary_kind,
      $2::uuid,
      $3::numeric,
      $4::varchar(3)
    );
    `,
    [paymentId, purchase.seller_id, payeeNet, currency]
  );

  // Ledger credits (wallet_transactions)
  const noteBase =
    args.note ??
    `Purchase payment for property ${purchase.property_id} (purchase ${purchase.id})`;

  // platform fee -> platform wallet
  await creditPlatformFee(client, {
    organizationId: purchase.organization_id,
    referenceType: "purchase",
    referenceId: purchase.id,
    amount: platformFee,
    currency,
    note: `Platform fee (2.5%) - ${noteBase}`,
  });

  // payee net -> seller wallet
  await creditPayee(client, {
    organizationId: purchase.organization_id,
    payeeUserId: purchase.seller_id,
    referenceType: "purchase",
    referenceId: purchase.id,
    amount: payeeNet,
    currency,
    note: `Seller net - ${noteBase}`,
  });

  // Optional: move purchase status forward (light-touch)
  // If full amount paid equals agreed_price, mark closed, else mark deposit_paid.
  if (Number(amount) >= Number(agreed)) {
    await client.query(
      `
      UPDATE public.property_purchases
      SET status = 'closed'::purchase_status,
          closed_at = COALESCE(closed_at, NOW())
      WHERE id = $1::uuid
        AND deleted_at IS NULL;
      `,
      [purchase.id]
    );
  } else {
    await client.query(
      `
      UPDATE public.property_purchases
      SET status = CASE
          WHEN status IN ('initiated','offer_made','offer_accepted','under_contract','escrow_opened')
          THEN 'deposit_paid'::purchase_status
          ELSE status
        END
      WHERE id = $1::uuid
        AND deleted_at IS NULL;
      `,
      [purchase.id]
    );
  }

  return {
    purchaseId: purchase.id,
    paymentId,
    platformFee,
    payeeNet,
    currency,
  };
}
