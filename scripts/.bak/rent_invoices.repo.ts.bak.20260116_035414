import type { PoolClient } from "pg";
import type { InvoiceStatus } from "../schemas/rent_invoices.schema.js";

type InsertArgs = {
  tenancy_id: string;
  tenant_id: string;
  property_id: string;

  period_start: string;
  period_end: string;
  due_date: string;

  subtotal: number;
  late_fee_amount: number;
  total_amount: number;

  currency: string;
  status: InvoiceStatus;
  notes?: string | null;
};

const RENT_INVOICE_SELECT = `
  id,
  organization_id,
  tenancy_id,
  tenant_id,
  property_id,
  invoice_number,
  status,
  period_start::text AS period_start,
  period_end::text AS period_end,
  due_date::text AS due_date,
  subtotal::text AS subtotal,
  late_fee_amount::text AS late_fee_amount,
  total_amount::text AS total_amount,
  currency,
  paid_amount::text AS paid_amount,
  paid_at::text AS paid_at,
  notes,
  created_at::text AS created_at,
  updated_at::text AS updated_at,
  deleted_at::text AS deleted_at
`;

export async function findRentInvoiceByTenancyPeriod(
  client: PoolClient,
  args: { tenancy_id: string; period_start: string; period_end: string; due_date: string }
) {
  const { rows } = await client.query(
    `
    SELECT ${RENT_INVOICE_SELECT}
    FROM public.rent_invoices
    WHERE tenancy_id = $1::uuid
      AND period_start = $2::date
      AND period_end   = $3::date
      AND due_date     = $4::date
      AND deleted_at IS NULL
    LIMIT 1;
    `,
    [args.tenancy_id, args.period_start, args.period_end, args.due_date]
  );
  return rows[0] ?? null;
}

export async function listRentInvoices(
  client: PoolClient,
  args: {
    limit: number;
    offset: number;
    tenancy_id?: string;
    tenant_id?: string;
    property_id?: string;
    status?: InvoiceStatus;
  }
) {
  const where: string[] = ["deleted_at IS NULL"];
  const vals: any[] = [];
  let i = 1;

  if (args.tenancy_id) { where.push(`tenancy_id = $${i++}::uuid`); vals.push(args.tenancy_id); }
  if (args.tenant_id) { where.push(`tenant_id = $${i++}::uuid`); vals.push(args.tenant_id); }
  if (args.property_id) { where.push(`property_id = $${i++}::uuid`); vals.push(args.property_id); }
  if (args.status) { where.push(`status = $${i++}::invoice_status`); vals.push(args.status); }

  vals.push(args.limit);
  vals.push(args.offset);

  const { rows } = await client.query(
    `
    SELECT ${RENT_INVOICE_SELECT}
    FROM public.rent_invoices
    WHERE ${where.join(" AND ")}
    ORDER BY created_at DESC
    LIMIT $${i++} OFFSET $${i++};
    `,
    vals
  );

  return rows;
}

/**
 * CRITICAL FIX:
 * organization_id must NOT be NULL.
 * We set it explicitly from current_organization_uuid(),
 * which reads from set_config() values we apply in the route.
 */
export async function insertRentInvoice(client: PoolClient, args: InsertArgs) {
  const { rows } = await client.query(
    `
    INSERT INTO public.rent_invoices (
      organization_id,
      tenancy_id,
      tenant_id,
      property_id,
      period_start,
      period_end,
      due_date,
      subtotal,
      late_fee_amount,
      total_amount,
      currency,
      status,
      notes
    )
    VALUES (
      public.current_organization_uuid(),
      $1::uuid,
      $2::uuid,
      $3::uuid,
      $4::date,
      $5::date,
      $6::date,
      $7::numeric,
      $8::numeric,
      $9::numeric,
      $10::varchar,
      $11::invoice_status,
      $12::text
    )
    RETURNING ${RENT_INVOICE_SELECT};
    `,
    [
      args.tenancy_id,
      args.tenant_id,
      args.property_id,
      args.period_start,
      args.period_end,
      args.due_date,
      args.subtotal,
      args.late_fee_amount,
      args.total_amount,
      args.currency,
      args.status,
      args.notes ?? null,
    ]
  );

  return rows[0];
}
