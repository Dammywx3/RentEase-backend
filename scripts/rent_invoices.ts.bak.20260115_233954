import type { FastifyInstance } from "fastify";
import { z } from "zod";
import { pool } from "../config/database.js";
import {
  generateRentInvoiceForTenancy,
  getRentInvoices,
  payRentInvoiceById,
} from "../services/rent_invoices.service.js";
import {
  GenerateRentInvoiceBodySchema,
  ListRentInvoicesQuerySchema,
  PayRentInvoiceBodySchema,
} from "../schemas/rent_invoices.schema.js";

/**
 * Sets RLS context variables used by your DB helper functions:
 * - request.jwt.claim.sub
 * - request.jwt.claim.role
 * - request.header.x_organization_id   (underscore, NOT hyphen)
 */
async function setRlsContext(client: any, req: any) {
  const orgId = (req.headers["x-organization-id"] ?? req.headers["x_organization_id"]) as string | undefined;
  const user = req.user as any;

  const userId = user?.sub || user?.id;
  const role = user?.role;

  if (!userId) {
    const e: any = new Error("Missing authenticated user id (req.user.sub)");
    e.code = "USER_ID_MISSING";
    throw e;
  }
  if (!orgId) {
    const e: any = new Error(
      "Missing organization context. Ensure x-organization-id is set and RLS context is applied."
    );
    e.code = "ORG_CONTEXT_MISSING";
    throw e;
  }

  await client.query(
    `
    SELECT
      set_config('request.jwt.claim.sub', $1, true),
      set_config('request.jwt.claim.role', $2, true),
      set_config('request.header.x_organization_id', $3, true);
    `,
    [userId, role ?? "", orgId]
  );
}

async function ensureAuth(req: any) {
  // fastify-jwt typically provides req.jwtVerify()
  if (typeof req.jwtVerify === "function") {
    await req.jwtVerify();
  }
}

export async function rentInvoicesRoutes(app: FastifyInstance) {
  // List invoices
  app.get("/v1/rent-invoices", async (req, reply) => {
    try {
      await ensureAuth(req);

      const q = ListRentInvoicesQuerySchema.parse((req as any).query);

      const client = await pool.connect();
      try {
        await setRlsContext(client, req);

        const data = await getRentInvoices(client, {
          limit: q.limit,
          offset: q.offset,
          tenancyId: q.tenancyId,
          tenantId: q.tenantId,
          propertyId: q.propertyId,
          status: q.status,
        });

        return reply.send({ ok: true, data, paging: { limit: q.limit, offset: q.offset } });
      } finally {
        client.release();
      }
    } catch (err: any) {
      return reply
        .code(500)
        .send({ ok: false, error: err?.code ?? "INTERNAL_ERROR", message: err?.message ?? String(err) });
    }
  });

  // Generate (idempotent) invoice for a tenancy
  app.post("/v1/tenancies/:id/rent-invoices/generate", async (req, reply) => {
    try {
      await ensureAuth(req);

      const params = z.object({ id: z.string().uuid() }).parse(req.params);
      const body = GenerateRentInvoiceBodySchema.parse(req.body);

      const client = await pool.connect();
      try {
        await client.query("BEGIN");
        await setRlsContext(client, req);

        const res = await generateRentInvoiceForTenancy(client, {
          tenancyId: params.id,
          periodStart: body.periodStart,
          periodEnd: body.periodEnd,
          dueDate: body.dueDate,
          subtotal: body.subtotal,
          lateFeeAmount: body.lateFeeAmount,
          currency: body.currency,
          status: body.status,
          notes: body.notes,
        });

        await client.query("COMMIT");
        return reply.send({ ok: true, reused: res.reused, data: res.row });
      } catch (err: any) {
        await client.query("ROLLBACK");
        throw err;
      } finally {
        client.release();
      }
    } catch (err: any) {
      return reply
        .code(500)
        .send({ ok: false, error: err?.code ?? "INTERNAL_ERROR", message: err?.message ?? String(err) });
    }
  });

  /**
   * PAY invoice
   * POST /v1/rent-invoices/:id/pay
   * Body: { paymentMethod, amount?, currency? }
   *
   * Note: invoice_payments insert policy requires admin or DB user 'rentease_service'.
   * If you want tenants to pay, you must run this endpoint using the service DB role OR loosen policy.
   */
  app.post("/v1/rent-invoices/:id/pay", async (req, reply) => {
    try {
      await ensureAuth(req);

      const params = z.object({ id: z.string().uuid() }).parse(req.params);
      const body = PayRentInvoiceBodySchema.parse(req.body);

      const role = (req as any).user?.role;
      if (role !== "admin") {
        return reply.code(403).send({ ok: false, error: "FORBIDDEN", message: "Admin only for now (policy requires admin or service role)." });
      }

      const client = await pool.connect();
      try {
        await client.query("BEGIN");
        await setRlsContext(client, req);

        const res = await payRentInvoiceById(client, {
          invoiceId: params.id,
          paymentMethod: body.paymentMethod,
          amount: body.amount,
          currency: body.currency,
        });

        await client.query("COMMIT");
        return reply.send({ ok: true, data: res.invoice, payment_id: res.payment_id });
      } catch (err: any) {
        await client.query("ROLLBACK");
        throw err;
      } finally {
        client.release();
      }
    } catch (err: any) {
      return reply
        .code(500)
        .send({ ok: false, error: err?.code ?? "INTERNAL_ERROR", message: err?.message ?? String(err) });
    }
  });
}
