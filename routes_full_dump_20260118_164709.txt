============================================================
RentEase: FULL ROUTES DUMP (route declarations + context)
Generated: Sun Jan 18 16:47:09 WAT 2026
PWD: /Users/mac/Downloads/RentEase--Backend
============================================================

Route files:
 - src/routes/applications.ts
 - src/routes/auth.ts
 - src/routes/debug_pgctx.ts
 - src/routes/demo.ts
 - src/routes/health.ts
 - src/routes/index.ts
 - src/routes/listings.ts
 - src/routes/me.ts
 - src/routes/organizations.ts
 - src/routes/payments.ts
 - src/routes/properties.ts
 - src/routes/purchase_close.ts
 - src/routes/purchase_escrow.ts
 - src/routes/purchases.routes.ts
 - src/routes/rent_invoices.ts
 - src/routes/tenancies.ts
 - src/routes/viewings.ts
 - src/routes/webhooks.ts

================ ROUTE DECLARATION LINES ===================
============================================================
FILE: src/routes/applications.ts
------------------------------------------------------------
86:  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
115:  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
136:  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
172:  app.patch("/:id", { preHandler: [app.authenticate] }, async (req: any) => {

============================================================
FILE: src/routes/auth.ts
------------------------------------------------------------
14:  app.post("/register", async (req, reply) => {
55:  app.post("/login", async (req, reply) => {

============================================================
FILE: src/routes/debug_pgctx.ts
------------------------------------------------------------
18:  app.get("/debug/pgctx", { preHandler: [app.authenticate] }, async (req: any) => {

============================================================
FILE: src/routes/demo.ts
------------------------------------------------------------
5:  app.get("/demo/public", async () => {
10:  app.get(

============================================================
FILE: src/routes/health.ts
------------------------------------------------------------
4:  app.get("/health", async () => {

============================================================
FILE: src/routes/index.ts
------------------------------------------------------------
  (no routes found)

============================================================
FILE: src/routes/listings.ts
------------------------------------------------------------
24:  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
40:  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
53:  app.post(", { preHandler: [app.authenticate] }, async (req: any, reply) => {
102:  app.patch("/:id", { preHandler: [app.authenticate] }, async (req: any) => {

============================================================
FILE: src/routes/me.ts
------------------------------------------------------------
21:  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {

============================================================
FILE: src/routes/organizations.ts
------------------------------------------------------------
57:  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
71:  app.put("/:id", { preHandler: [app.authenticate] }, async (req: any) => {

============================================================
FILE: src/routes/payments.ts
------------------------------------------------------------
16:  app.post(
91:  app.get("/paystack/finalize",

============================================================
FILE: src/routes/properties.ts
------------------------------------------------------------
30:  app.post(
56:  app.get(
86:  app.get(
114:  app.patch(

============================================================
FILE: src/routes/purchase_close.ts
------------------------------------------------------------
24:  app.post(

============================================================
FILE: src/routes/purchase_escrow.ts
------------------------------------------------------------
15:  app.get("/:id/release-escrow",

============================================================
FILE: src/routes/purchases.routes.ts
------------------------------------------------------------
  (no routes found)

============================================================
FILE: src/routes/rent_invoices.ts
------------------------------------------------------------
86:  app.post(
157:  app.get("/", { preHandler: [app.authenticate] }, async (req, reply) => {
212:  app.get("/:id/pay", { preHandler: [app.authenticate] }, async (req, reply) => {

============================================================
FILE: src/routes/tenancies.ts
------------------------------------------------------------
  (no routes found)

============================================================
FILE: src/routes/viewings.ts
------------------------------------------------------------
17:  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
38:  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
52:  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
80:  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {

============================================================
FILE: src/routes/webhooks.ts
------------------------------------------------------------
145:  app.post(

================ ROUTE HANDLER CONTEXT =====================
============================================================
FILE: src/routes/applications.ts
------------------------------------------------------------

---- CONTEXT around line 86 (showing 78..166) ----
    78	  const userId = String(req?.user?.userId ?? "").trim();
    79	  const organizationId = String(req?.orgId ?? "").trim();
    80	  const role = (req?.user?.role ?? null) as any;
    81	  return { userId, organizationId, role };
    82	}
    83	
    84	export async function applicationRoutes(app: FastifyInstance) {
    85	  // LIST
    86	  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
    87	    const q = listApplicationsQuerySchema.parse(req.query ?? {});
    88	    const ctx = getCtx(req);
    89	
    90	    const data = await withRlsTransaction(
    91	      {
    92	        userId: ctx.userId,
    93	        organizationId: ctx.organizationId,
    94	        role: ctx.role,
    95	        eventNote: "applications:list",
    96	      },
    97	      async (client: PoolClient) => {
    98	        const rows = await listAllApplications(client, {
    99	          limit: q.limit,
   100	          offset: q.offset,
   101	          listing_id: q.listingId,
   102	          property_id: q.propertyId,
   103	          applicant_id: q.applicantId,
   104	          status: q.status ?? undefined,
   105	        });
   106	
   107	        return normalizeApplicationRows(rows as any[]);
   108	      }
   109	    );
   110	
   111	    return { ok: true, data, paging: { limit: q.limit, offset: q.offset } };
   112	  });
   113	
   114	  // GET ONE
   115	  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
   116	    const { id } = req.params as any;
   117	    const ctx = getCtx(req);
   118	
   119	    const data = await withRlsTransaction(
   120	      {
   121	        userId: ctx.userId,
   122	        organizationId: ctx.organizationId,
   123	        role: ctx.role,
   124	        eventNote: `applications:get:${String(id)}`,
   125	      },
   126	      async (client: PoolClient) => {
   127	        const row = await getApplication(client, String(id));
   128	        return normalizeApplicationRow(row);
   129	      }
   130	    );
   131	
   132	    return { ok: true, data };
   133	  });
   134	
   135	  // CREATE
   136	  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
   137	    const body = createApplicationBodySchema.parse(req.body ?? {});
   138	    const ctx = getCtx(req);
   139	
   140	    const allowStatus = req.user?.role === "admin";
   141	    const status = allowStatus ? (body.status ?? undefined) : undefined;
   142	
   143	    const data = await withRlsTransaction(
   144	      {
   145	        userId: ctx.userId,
   146	        organizationId: ctx.organizationId,
   147	        role: ctx.role,
   148	        eventNote: "applications:create",
   149	      },
   150	      async (client: PoolClient) => {
   151	        const row = await createApplication(
   152	          client,
   153	          { userId: ctx.userId },
   154	          {
   155	            listing_id: body.listingId,
   156	            property_id: body.propertyId,
   157	            message: body.message ?? null,
   158	            monthly_income: body.monthlyIncome ?? null,
   159	            move_in_date: normalizeDateOnlyInput(body.moveInDate),
   160	            status,
   161	          }
   162	        );
   163	
   164	        return normalizeApplicationRow(row);
   165	      }
   166	    );

---- CONTEXT around line 115 (showing 107..195) ----
   107	        return normalizeApplicationRows(rows as any[]);
   108	      }
   109	    );
   110	
   111	    return { ok: true, data, paging: { limit: q.limit, offset: q.offset } };
   112	  });
   113	
   114	  // GET ONE
   115	  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
   116	    const { id } = req.params as any;
   117	    const ctx = getCtx(req);
   118	
   119	    const data = await withRlsTransaction(
   120	      {
   121	        userId: ctx.userId,
   122	        organizationId: ctx.organizationId,
   123	        role: ctx.role,
   124	        eventNote: `applications:get:${String(id)}`,
   125	      },
   126	      async (client: PoolClient) => {
   127	        const row = await getApplication(client, String(id));
   128	        return normalizeApplicationRow(row);
   129	      }
   130	    );
   131	
   132	    return { ok: true, data };
   133	  });
   134	
   135	  // CREATE
   136	  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
   137	    const body = createApplicationBodySchema.parse(req.body ?? {});
   138	    const ctx = getCtx(req);
   139	
   140	    const allowStatus = req.user?.role === "admin";
   141	    const status = allowStatus ? (body.status ?? undefined) : undefined;
   142	
   143	    const data = await withRlsTransaction(
   144	      {
   145	        userId: ctx.userId,
   146	        organizationId: ctx.organizationId,
   147	        role: ctx.role,
   148	        eventNote: "applications:create",
   149	      },
   150	      async (client: PoolClient) => {
   151	        const row = await createApplication(
   152	          client,
   153	          { userId: ctx.userId },
   154	          {
   155	            listing_id: body.listingId,
   156	            property_id: body.propertyId,
   157	            message: body.message ?? null,
   158	            monthly_income: body.monthlyIncome ?? null,
   159	            move_in_date: normalizeDateOnlyInput(body.moveInDate),
   160	            status,
   161	          }
   162	        );
   163	
   164	        return normalizeApplicationRow(row);
   165	      }
   166	    );
   167	
   168	    return { ok: true, data };
   169	  });
   170	
   171	  // PATCH
   172	  app.patch("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
   173	    const { id } = req.params as any;
   174	    const body = patchApplicationBodySchema.parse(req.body ?? {});
   175	    const ctx = getCtx(req);
   176	
   177	    const patch: any = {};
   178	    if (body.status !== undefined) patch.status = body.status;
   179	    if (body.message !== undefined) patch.message = body.message;
   180	    if (body.monthlyIncome !== undefined) patch.monthly_income = body.monthlyIncome;
   181	
   182	    if (body.moveInDate !== undefined) {
   183	      patch.move_in_date = normalizeDateOnlyInput(body.moveInDate);
   184	    }
   185	
   186	    const data = await withRlsTransaction(
   187	      {
   188	        userId: ctx.userId,
   189	        organizationId: ctx.organizationId,
   190	        role: ctx.role,
   191	        eventNote: `applications:patch:${String(id)}`,
   192	      },
   193	      async (client: PoolClient) => {
   194	        const row = await updateApplication(client, String(id), patch);
   195	        return normalizeApplicationRow(row);

---- CONTEXT around line 136 (showing 128..216) ----
   128	        return normalizeApplicationRow(row);
   129	      }
   130	    );
   131	
   132	    return { ok: true, data };
   133	  });
   134	
   135	  // CREATE
   136	  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
   137	    const body = createApplicationBodySchema.parse(req.body ?? {});
   138	    const ctx = getCtx(req);
   139	
   140	    const allowStatus = req.user?.role === "admin";
   141	    const status = allowStatus ? (body.status ?? undefined) : undefined;
   142	
   143	    const data = await withRlsTransaction(
   144	      {
   145	        userId: ctx.userId,
   146	        organizationId: ctx.organizationId,
   147	        role: ctx.role,
   148	        eventNote: "applications:create",
   149	      },
   150	      async (client: PoolClient) => {
   151	        const row = await createApplication(
   152	          client,
   153	          { userId: ctx.userId },
   154	          {
   155	            listing_id: body.listingId,
   156	            property_id: body.propertyId,
   157	            message: body.message ?? null,
   158	            monthly_income: body.monthlyIncome ?? null,
   159	            move_in_date: normalizeDateOnlyInput(body.moveInDate),
   160	            status,
   161	          }
   162	        );
   163	
   164	        return normalizeApplicationRow(row);
   165	      }
   166	    );
   167	
   168	    return { ok: true, data };
   169	  });
   170	
   171	  // PATCH
   172	  app.patch("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
   173	    const { id } = req.params as any;
   174	    const body = patchApplicationBodySchema.parse(req.body ?? {});
   175	    const ctx = getCtx(req);
   176	
   177	    const patch: any = {};
   178	    if (body.status !== undefined) patch.status = body.status;
   179	    if (body.message !== undefined) patch.message = body.message;
   180	    if (body.monthlyIncome !== undefined) patch.monthly_income = body.monthlyIncome;
   181	
   182	    if (body.moveInDate !== undefined) {
   183	      patch.move_in_date = normalizeDateOnlyInput(body.moveInDate);
   184	    }
   185	
   186	    const data = await withRlsTransaction(
   187	      {
   188	        userId: ctx.userId,
   189	        organizationId: ctx.organizationId,
   190	        role: ctx.role,
   191	        eventNote: `applications:patch:${String(id)}`,
   192	      },
   193	      async (client: PoolClient) => {
   194	        const row = await updateApplication(client, String(id), patch);
   195	        return normalizeApplicationRow(row);
   196	      }
   197	    );
   198	
   199	    return { ok: true, data };
   200	  });
   201	}

---- CONTEXT around line 172 (showing 164..252) ----
   164	        return normalizeApplicationRow(row);
   165	      }
   166	    );
   167	
   168	    return { ok: true, data };
   169	  });
   170	
   171	  // PATCH
   172	  app.patch("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
   173	    const { id } = req.params as any;
   174	    const body = patchApplicationBodySchema.parse(req.body ?? {});
   175	    const ctx = getCtx(req);
   176	
   177	    const patch: any = {};
   178	    if (body.status !== undefined) patch.status = body.status;
   179	    if (body.message !== undefined) patch.message = body.message;
   180	    if (body.monthlyIncome !== undefined) patch.monthly_income = body.monthlyIncome;
   181	
   182	    if (body.moveInDate !== undefined) {
   183	      patch.move_in_date = normalizeDateOnlyInput(body.moveInDate);
   184	    }
   185	
   186	    const data = await withRlsTransaction(
   187	      {
   188	        userId: ctx.userId,
   189	        organizationId: ctx.organizationId,
   190	        role: ctx.role,
   191	        eventNote: `applications:patch:${String(id)}`,
   192	      },
   193	      async (client: PoolClient) => {
   194	        const row = await updateApplication(client, String(id), patch);
   195	        return normalizeApplicationRow(row);
   196	      }
   197	    );
   198	
   199	    return { ok: true, data };
   200	  });
   201	}

============================================================
FILE: src/routes/auth.ts
------------------------------------------------------------

---- CONTEXT around line 14 (showing 6..94) ----
     6	  createUser,
     7	  getUserByEmail,
     8	  markLoginFailure,
     9	  markLoginSuccess,
    10	} from "../repositories/users.repo.js";
    11	
    12	export async function authRoutes(app: FastifyInstance) {
    13	  // Register
    14	  app.post("/register", async (req, reply) => {
    15	    const body = registerSchema.parse(req.body);
    16	
    17	    const passwordHash = await hashPassword(body.password);
    18	
    19	    try {
    20	      const user = await createUser({
    21	        organizationId: body.organizationId,
    22	        fullName: body.fullName,
    23	        email: body.email.toLowerCase(),
    24	        phone: body.phone,
    25	        passwordHash,
    26	        role: body.role,
    27	      });
    28	
    29	      const token = app.jwt.sign({
    30	        sub: user.id,
    31	        org: String(user.organization_id ?? ""),
    32	        role: user.role,
    33	        email: user.email,
    34	      });
    35	
    36	      return reply.code(201).send({
    37	        ok: true,
    38	        token,
    39	        user,
    40	      });
    41	    } catch (err: any) {
    42	      // unique violation in Postgres
    43	      if (err?.code === "23505") {
    44	        return reply.code(409).send({
    45	          ok: false,
    46	          error: "EMAIL_EXISTS",
    47	          message: "Email already registered",
    48	        });
    49	      }
    50	      throw err;
    51	    }
    52	  });
    53	
    54	  // Login
    55	  app.post("/login", async (req, reply) => {
    56	    const body = loginSchema.parse(req.body);
    57	
    58	    const user = await getUserByEmail(body.email.toLowerCase());
    59	    if (!user) {
    60	      return reply
    61	        .code(401)
    62	        .send({ ok: false, error: "UNAUTHORIZED", message: "Invalid credentials" });
    63	    }
    64	
    65	    // ✅ 0) permanent lock check
    66	    if (user.account_locked_permanent) {
    67	      return reply.code(423).send({
    68	        ok: false,
    69	        error: "ACCOUNT_LOCKED",
    70	        message: "Account locked. Contact support.",
    71	      });
    72	    }
    73	
    74	    // ✅ 1) temp lock check
    75	    if (user.account_locked_until) {
    76	      const lockedUntil = new Date(user.account_locked_until);
    77	      if (lockedUntil.getTime() > Date.now()) {
    78	        return reply.code(423).send({
    79	          ok: false,
    80	          error: "ACCOUNT_LOCKED",
    81	          message: "Too many attempts. Try again in 5 minutes.",
    82	          lockedUntil,
    83	        });
    84	      }
    85	      // if expired, allow login attempt (repo handles stage escalation on next wrong)
    86	    }
    87	
    88	    const ok = await verifyPassword(body.password, user.password_hash);
    89	
    90	    if (!ok) {
    91	      const { attempts, lockedUntil, permanentlyLocked } = await markLoginFailure(
    92	        user.id
    93	      );
    94	

---- CONTEXT around line 55 (showing 47..135) ----
    47	          message: "Email already registered",
    48	        });
    49	      }
    50	      throw err;
    51	    }
    52	  });
    53	
    54	  // Login
    55	  app.post("/login", async (req, reply) => {
    56	    const body = loginSchema.parse(req.body);
    57	
    58	    const user = await getUserByEmail(body.email.toLowerCase());
    59	    if (!user) {
    60	      return reply
    61	        .code(401)
    62	        .send({ ok: false, error: "UNAUTHORIZED", message: "Invalid credentials" });
    63	    }
    64	
    65	    // ✅ 0) permanent lock check
    66	    if (user.account_locked_permanent) {
    67	      return reply.code(423).send({
    68	        ok: false,
    69	        error: "ACCOUNT_LOCKED",
    70	        message: "Account locked. Contact support.",
    71	      });
    72	    }
    73	
    74	    // ✅ 1) temp lock check
    75	    if (user.account_locked_until) {
    76	      const lockedUntil = new Date(user.account_locked_until);
    77	      if (lockedUntil.getTime() > Date.now()) {
    78	        return reply.code(423).send({
    79	          ok: false,
    80	          error: "ACCOUNT_LOCKED",
    81	          message: "Too many attempts. Try again in 5 minutes.",
    82	          lockedUntil,
    83	        });
    84	      }
    85	      // if expired, allow login attempt (repo handles stage escalation on next wrong)
    86	    }
    87	
    88	    const ok = await verifyPassword(body.password, user.password_hash);
    89	
    90	    if (!ok) {
    91	      const { attempts, lockedUntil, permanentlyLocked } = await markLoginFailure(
    92	        user.id
    93	      );
    94	
    95	      // ✅ permanent lock just triggered
    96	      if (permanentlyLocked) {
    97	        return reply.code(423).send({
    98	          ok: false,
    99	          error: "ACCOUNT_LOCKED",
   100	          message: "Account locked. Contact support.",
   101	        });
   102	      }
   103	
   104	      // ✅ temp lock just triggered (3rd wrong)
   105	      if (lockedUntil) {
   106	        return reply.code(423).send({
   107	          ok: false,
   108	          error: "ACCOUNT_LOCKED",
   109	          message: "Too many attempts. Try again in 5 minutes.",
   110	          attempts,
   111	          lockedUntil,
   112	        });
   113	      }
   114	
   115	      // normal wrong attempt (1st/2nd)
   116	      return reply.code(401).send({
   117	        ok: false,
   118	        error: "UNAUTHORIZED",
   119	        message: "Invalid credentials",
   120	        attempts,
   121	      });
   122	    }
   123	
   124	    // ✅ success resets attempts + locks + stage
   125	    await markLoginSuccess(user.id);
   126	
   127	    const token = app.jwt.sign({
   128	      sub: user.id,
   129	      org: String(user.organization_id ?? ""),
   130	      role: user.role,
   131	      email: user.email,
   132	    });
   133	
   134	    return reply.send({
   135	      ok: true,

============================================================
FILE: src/routes/debug_pgctx.ts
------------------------------------------------------------

---- CONTEXT around line 18 (showing 10..98) ----
    10	
    11	  if (!userId) throw new Error("debug_pgctx: missing req.user.userId");
    12	  if (!organizationId) throw new Error("debug_pgctx: missing req.orgId");
    13	
    14	  return { userId, organizationId, role };
    15	}
    16	
    17	export async function debugPgCtxRoutes(app: FastifyInstance) {
    18	  app.get("/debug/pgctx", { preHandler: [app.authenticate] }, async (req: any) => {
    19	    const ctx = getCtx(req);
    20	
    21	    const data = await withRlsTransaction(
    22	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: "debug:pgctx" },
    23	      async (client: PoolClient) => {
    24	        const { rows } = await client.query(`
    25	          SELECT
    26	            current_setting('app.organization_id', true) AS org_id,
    27	            current_setting('app.user_id', true) AS user_id,
    28	            current_setting('app.user_role', true) AS role,
    29	            current_setting('app.event_note', true) AS event_note,
    30	            current_setting('request.header.x_organization_id', true) AS hdr_org,
    31	            current_setting('request.jwt.claim.sub', true) AS jwt_sub
    32	        `);
    33	
    34	        return rows[0] ?? null;
    35	      }
    36	    );
    37	
    38	    return { ok: true, data };
    39	  });
    40	}

============================================================
FILE: src/routes/demo.ts
------------------------------------------------------------

---- CONTEXT around line 5 (showing 1..85) ----
     1	import type { FastifyInstance } from "fastify";
     2	
     3	export async function demoRoutes(app: FastifyInstance) {
     4	  // Public demo
     5	  app.get("/demo/public", async () => {
     6	    return { ok: true, message: "Public demo route" };
     7	  });
     8	
     9	  // Protected demo (requires JWT)
    10	  app.get(
    11	    "/demo/protected",
    12	    { preHandler: [app.authenticate] },
    13	    async (req) => {
    14	      return {
    15	        ok: true,
    16	        message: "Protected demo route",
    17	        user: req.user,
    18	      };
    19	    }
    20	  );
    21	}

---- CONTEXT around line 10 (showing 2..90) ----
     2	
     3	export async function demoRoutes(app: FastifyInstance) {
     4	  // Public demo
     5	  app.get("/demo/public", async () => {
     6	    return { ok: true, message: "Public demo route" };
     7	  });
     8	
     9	  // Protected demo (requires JWT)
    10	  app.get(
    11	    "/demo/protected",
    12	    { preHandler: [app.authenticate] },
    13	    async (req) => {
    14	      return {
    15	        ok: true,
    16	        message: "Protected demo route",
    17	        user: req.user,
    18	      };
    19	    }
    20	  );
    21	}

============================================================
FILE: src/routes/health.ts
------------------------------------------------------------

---- CONTEXT around line 4 (showing 1..84) ----
     1	import { FastifyInstance } from "fastify";
     2	
     3	export async function healthRoutes(app: FastifyInstance) {
     4	  app.get("/health", async () => {
     5	    return { ok: true, service: "RentEase API", time: new Date().toISOString() };
     6	  });
     7	}
============================================================
FILE: src/routes/listings.ts
------------------------------------------------------------

---- CONTEXT around line 24 (showing 16..104) ----
    16	  const userId = String(req?.user?.userId ?? "").trim();
    17	  const organizationId = String(req?.orgId ?? "").trim();
    18	  const role = (req?.user?.role ?? null) as any;
    19	  return { userId, organizationId, role };
    20	}
    21	
    22	export async function listingRoutes(app: FastifyInstance) {
    23	  // LIST
    24	  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
    25	    const q = req.query as any;
    26	    const limit = Math.max(1, Math.min(100, Number(q.limit ?? 10)));
    27	    const offset = Math.max(0, Number(q.offset ?? 0));
    28	
    29	    const ctx = getCtx(req);
    30	
    31	    const data = await withRlsTransaction(
    32	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: "listings:list" },
    33	      async (client: PoolClient) => listAllListings(client, { limit, offset })
    34	    );
    35	
    36	    return { ok: true, data, paging: { limit, offset } };
    37	  });
    38	
    39	  // GET ONE
    40	  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
    41	    const { id } = req.params as any;
    42	    const ctx = getCtx(req);
    43	
    44	    const data = await withRlsTransaction(
    45	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `listings:get:${String(id)}` },
    46	      async (client: PoolClient) => getListing(client, id)
    47	    );
    48	
    49	    return { ok: true, data };
    50	  });
    51	
    52	  // CREATE
    53	  app.post(", { preHandler: [app.authenticate] }, async (req: any, reply) => {
    54	    const body = req.body as CreateListingBody;
    55	
    56	    // app-level checks to avoid DB trigger errors
    57	    if (!body.propertyId) return reply.code(400).send({ ok: false, message: "propertyId is required" });
    58	    if (!body.kind) return reply.code(400).send({ ok: false, message: "kind is required" });
    59	    if (!body.payeeUserId) return reply.code(400).send({ ok: false, message: "payeeUserId is required" });
    60	    if (typeof body.basePrice !== "number" || body.basePrice <= 0) {
    61	      return reply.code(400).send({ ok: false, message: "basePrice must be > 0" });
    62	    }
    63	    if (typeof body.listedPrice !== "number" || body.listedPrice <= 0) {
    64	      return reply.code(400).send({ ok: false, message: "listedPrice must be > 0" });
    65	    }
    66	
    67	    // schema trigger expects agent_id for agent_direct (and usually agent_partner too)
    68	    if ((body.kind === "agent_direct" || body.kind === "agent_partner") && !body.agentId) {
    69	      return reply.code(400).send({ ok: false, message: `${body.kind} listing requires agentId` });
    70	    }
    71	
    72	    const ctx = getCtx(req);
    73	
    74	    const data = await withRlsTransaction(
    75	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: "listings:create" },
    76	      async (client: PoolClient) => {
    77	        return createListing(client, {
    78	          property_id: body.propertyId,
    79	          kind: body.kind,
    80	
    81	          // omit status if not provided so DB default 'draft' applies
    82	          status: typeof body.status === "undefined" ? undefined : body.status,
    83	
    84	          agent_id: body.agentId ?? null,
    85	          payee_user_id: body.payeeUserId,
    86	
    87	          base_price: body.basePrice,
    88	          listed_price: body.listedPrice,
    89	
    90	          agent_commission_percent: body.agentCommissionPercent ?? null,
    91	          requires_owner_approval: body.requiresOwnerApproval ?? null,
    92	          is_public: body.isPublic ?? null,
    93	          public_note: body.publicNote ?? null,
    94	        });
    95	      }
    96	    );
    97	
    98	    return { ok: true, data };
    99	  });
   100	
   101	  // PATCH
   102	  app.patch("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
   103	    const { id } = req.params as any;
   104	    const body = req.body as PatchListingBody;

---- CONTEXT around line 40 (showing 32..120) ----
    32	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: "listings:list" },
    33	      async (client: PoolClient) => listAllListings(client, { limit, offset })
    34	    );
    35	
    36	    return { ok: true, data, paging: { limit, offset } };
    37	  });
    38	
    39	  // GET ONE
    40	  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
    41	    const { id } = req.params as any;
    42	    const ctx = getCtx(req);
    43	
    44	    const data = await withRlsTransaction(
    45	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `listings:get:${String(id)}` },
    46	      async (client: PoolClient) => getListing(client, id)
    47	    );
    48	
    49	    return { ok: true, data };
    50	  });
    51	
    52	  // CREATE
    53	  app.post(", { preHandler: [app.authenticate] }, async (req: any, reply) => {
    54	    const body = req.body as CreateListingBody;
    55	
    56	    // app-level checks to avoid DB trigger errors
    57	    if (!body.propertyId) return reply.code(400).send({ ok: false, message: "propertyId is required" });
    58	    if (!body.kind) return reply.code(400).send({ ok: false, message: "kind is required" });
    59	    if (!body.payeeUserId) return reply.code(400).send({ ok: false, message: "payeeUserId is required" });
    60	    if (typeof body.basePrice !== "number" || body.basePrice <= 0) {
    61	      return reply.code(400).send({ ok: false, message: "basePrice must be > 0" });
    62	    }
    63	    if (typeof body.listedPrice !== "number" || body.listedPrice <= 0) {
    64	      return reply.code(400).send({ ok: false, message: "listedPrice must be > 0" });
    65	    }
    66	
    67	    // schema trigger expects agent_id for agent_direct (and usually agent_partner too)
    68	    if ((body.kind === "agent_direct" || body.kind === "agent_partner") && !body.agentId) {
    69	      return reply.code(400).send({ ok: false, message: `${body.kind} listing requires agentId` });
    70	    }
    71	
    72	    const ctx = getCtx(req);
    73	
    74	    const data = await withRlsTransaction(
    75	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: "listings:create" },
    76	      async (client: PoolClient) => {
    77	        return createListing(client, {
    78	          property_id: body.propertyId,
    79	          kind: body.kind,
    80	
    81	          // omit status if not provided so DB default 'draft' applies
    82	          status: typeof body.status === "undefined" ? undefined : body.status,
    83	
    84	          agent_id: body.agentId ?? null,
    85	          payee_user_id: body.payeeUserId,
    86	
    87	          base_price: body.basePrice,
    88	          listed_price: body.listedPrice,
    89	
    90	          agent_commission_percent: body.agentCommissionPercent ?? null,
    91	          requires_owner_approval: body.requiresOwnerApproval ?? null,
    92	          is_public: body.isPublic ?? null,
    93	          public_note: body.publicNote ?? null,
    94	        });
    95	      }
    96	    );
    97	
    98	    return { ok: true, data };
    99	  });
   100	
   101	  // PATCH
   102	  app.patch("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
   103	    const { id } = req.params as any;
   104	    const body = req.body as PatchListingBody;
   105	
   106	    const ctx = getCtx(req);
   107	
   108	    const data = await withRlsTransaction(
   109	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `listings:patch:${String(id)}` },
   110	      async (client: PoolClient) => {
   111	        return updateListing(client, id, {
   112	          status: body.status ?? undefined,
   113	          agent_id: body.agentId ?? undefined,
   114	          payee_user_id: body.payeeUserId ?? undefined,
   115	          base_price: body.basePrice ?? undefined,
   116	          listed_price: body.listedPrice ?? undefined,
   117	          agent_commission_percent: body.agentCommissionPercent ?? undefined,
   118	          requires_owner_approval: body.requiresOwnerApproval ?? undefined,
   119	          is_public: body.isPublic ?? undefined,
   120	          public_note: body.publicNote ?? undefined,

---- CONTEXT around line 53 (showing 45..133) ----
    45	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `listings:get:${String(id)}` },
    46	      async (client: PoolClient) => getListing(client, id)
    47	    );
    48	
    49	    return { ok: true, data };
    50	  });
    51	
    52	  // CREATE
    53	  app.post(", { preHandler: [app.authenticate] }, async (req: any, reply) => {
    54	    const body = req.body as CreateListingBody;
    55	
    56	    // app-level checks to avoid DB trigger errors
    57	    if (!body.propertyId) return reply.code(400).send({ ok: false, message: "propertyId is required" });
    58	    if (!body.kind) return reply.code(400).send({ ok: false, message: "kind is required" });
    59	    if (!body.payeeUserId) return reply.code(400).send({ ok: false, message: "payeeUserId is required" });
    60	    if (typeof body.basePrice !== "number" || body.basePrice <= 0) {
    61	      return reply.code(400).send({ ok: false, message: "basePrice must be > 0" });
    62	    }
    63	    if (typeof body.listedPrice !== "number" || body.listedPrice <= 0) {
    64	      return reply.code(400).send({ ok: false, message: "listedPrice must be > 0" });
    65	    }
    66	
    67	    // schema trigger expects agent_id for agent_direct (and usually agent_partner too)
    68	    if ((body.kind === "agent_direct" || body.kind === "agent_partner") && !body.agentId) {
    69	      return reply.code(400).send({ ok: false, message: `${body.kind} listing requires agentId` });
    70	    }
    71	
    72	    const ctx = getCtx(req);
    73	
    74	    const data = await withRlsTransaction(
    75	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: "listings:create" },
    76	      async (client: PoolClient) => {
    77	        return createListing(client, {
    78	          property_id: body.propertyId,
    79	          kind: body.kind,
    80	
    81	          // omit status if not provided so DB default 'draft' applies
    82	          status: typeof body.status === "undefined" ? undefined : body.status,
    83	
    84	          agent_id: body.agentId ?? null,
    85	          payee_user_id: body.payeeUserId,
    86	
    87	          base_price: body.basePrice,
    88	          listed_price: body.listedPrice,
    89	
    90	          agent_commission_percent: body.agentCommissionPercent ?? null,
    91	          requires_owner_approval: body.requiresOwnerApproval ?? null,
    92	          is_public: body.isPublic ?? null,
    93	          public_note: body.publicNote ?? null,
    94	        });
    95	      }
    96	    );
    97	
    98	    return { ok: true, data };
    99	  });
   100	
   101	  // PATCH
   102	  app.patch("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
   103	    const { id } = req.params as any;
   104	    const body = req.body as PatchListingBody;
   105	
   106	    const ctx = getCtx(req);
   107	
   108	    const data = await withRlsTransaction(
   109	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `listings:patch:${String(id)}` },
   110	      async (client: PoolClient) => {
   111	        return updateListing(client, id, {
   112	          status: body.status ?? undefined,
   113	          agent_id: body.agentId ?? undefined,
   114	          payee_user_id: body.payeeUserId ?? undefined,
   115	          base_price: body.basePrice ?? undefined,
   116	          listed_price: body.listedPrice ?? undefined,
   117	          agent_commission_percent: body.agentCommissionPercent ?? undefined,
   118	          requires_owner_approval: body.requiresOwnerApproval ?? undefined,
   119	          is_public: body.isPublic ?? undefined,
   120	          public_note: body.publicNote ?? undefined,
   121	        });
   122	      }
   123	    );
   124	
   125	    return { ok: true, data };
   126	  });
   127	}

---- CONTEXT around line 102 (showing 94..182) ----
    94	        });
    95	      }
    96	    );
    97	
    98	    return { ok: true, data };
    99	  });
   100	
   101	  // PATCH
   102	  app.patch("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
   103	    const { id } = req.params as any;
   104	    const body = req.body as PatchListingBody;
   105	
   106	    const ctx = getCtx(req);
   107	
   108	    const data = await withRlsTransaction(
   109	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `listings:patch:${String(id)}` },
   110	      async (client: PoolClient) => {
   111	        return updateListing(client, id, {
   112	          status: body.status ?? undefined,
   113	          agent_id: body.agentId ?? undefined,
   114	          payee_user_id: body.payeeUserId ?? undefined,
   115	          base_price: body.basePrice ?? undefined,
   116	          listed_price: body.listedPrice ?? undefined,
   117	          agent_commission_percent: body.agentCommissionPercent ?? undefined,
   118	          requires_owner_approval: body.requiresOwnerApproval ?? undefined,
   119	          is_public: body.isPublic ?? undefined,
   120	          public_note: body.publicNote ?? undefined,
   121	        });
   122	      }
   123	    );
   124	
   125	    return { ok: true, data };
   126	  });
   127	}

============================================================
FILE: src/routes/me.ts
------------------------------------------------------------

---- CONTEXT around line 21 (showing 13..101) ----
    13	  if (!organizationId) throw new Error("ME_CTX_MISSING_ORG");
    14	
    15	  return { userId, organizationId, role };
    16	}
    17	
    18	export async function meRoutes(app: FastifyInstance) {
    19	  // NOTE: routes/index.ts already registers this plugin with prefix "/me"
    20	  // So inside here we use "/" (NOT "/me") to avoid "/v1/me/me"
    21	  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
    22	    const ctx = getCtx(req);
    23	
    24	    const me = await withRlsTransaction(
    25	      {
    26	        userId: ctx.userId,
    27	        organizationId: ctx.organizationId,
    28	        role: ctx.role,
    29	        eventNote: "me:get",
    30	      },
    31	      async (client: PoolClient) => {
    32	        const { rows } = await client.query(
    33	          `
    34	          SELECT
    35	            id,
    36	            organization_id,
    37	            full_name,
    38	            email,
    39	            phone,
    40	            role,
    41	            verified_status,
    42	            created_at,
    43	            updated_at
    44	          FROM public.users
    45	          WHERE id = $1
    46	          LIMIT 1
    47	          `,
    48	          [ctx.userId]
    49	        );
    50	
    51	        return rows[0] ?? null;
    52	      }
    53	    );
    54	
    55	    return { ok: true, data: me };
    56	  });
    57	}
============================================================
FILE: src/routes/organizations.ts
------------------------------------------------------------

---- CONTEXT around line 57 (showing 49..137) ----
    49	    `,
    50	    [id, name]
    51	  );
    52	  return rows[0] ?? null;
    53	}
    54	
    55	export async function organizationRoutes(app: FastifyInstance) {
    56	  // GET /v1/organizations/:id
    57	  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
    58	    const { id } = paramsSchema.parse((req as any).params);
    59	    const ctx = getCtx(req);
    60	
    61	    const org = await withRlsTransaction(
    62	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `org:get:${id}` },
    63	      async (client) => getOrg(client, id)
    64	    );
    65	
    66	    if (!org) return { ok: false, error: "NOT_FOUND", message: "Organization not found" };
    67	    return { ok: true, data: org };
    68	  });
    69	
    70	  // PUT /v1/organizations/:id
    71	  app.put("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
    72	    const { id } = paramsSchema.parse((req as any).params);
    73	    const body = updateBodySchema.parse((req as any).body);
    74	    const ctx = getCtx(req);
    75	
    76	    const updated = await withRlsTransaction(
    77	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `org:put:${id}` },
    78	      async (client) => updateOrgName(client, id, body.name)
    79	    );
    80	
    81	    if (!updated) return { ok: false, error: "NOT_FOUND", message: "Organization not found" };
    82	    return { ok: true, data: updated };
    83	  });
    84	}

---- CONTEXT around line 71 (showing 63..151) ----
    63	      async (client) => getOrg(client, id)
    64	    );
    65	
    66	    if (!org) return { ok: false, error: "NOT_FOUND", message: "Organization not found" };
    67	    return { ok: true, data: org };
    68	  });
    69	
    70	  // PUT /v1/organizations/:id
    71	  app.put("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
    72	    const { id } = paramsSchema.parse((req as any).params);
    73	    const body = updateBodySchema.parse((req as any).body);
    74	    const ctx = getCtx(req);
    75	
    76	    const updated = await withRlsTransaction(
    77	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `org:put:${id}` },
    78	      async (client) => updateOrgName(client, id, body.name)
    79	    );
    80	
    81	    if (!updated) return { ok: false, error: "NOT_FOUND", message: "Organization not found" };
    82	    return { ok: true, data: updated };
    83	  });
    84	}

============================================================
FILE: src/routes/payments.ts
------------------------------------------------------------

---- CONTEXT around line 16 (showing 8..96) ----
     8	  finalizePaystackSuccessForRentInvoice,
     9	} from "../services/rent_invoice_payments.service.js";
    10	
    11	export async function paymentsRoutes(app: FastifyInstance) {
    12	  // -------------------------------
    13	  // Create rent-invoice payment intent (AUTH)
    14	  // POST /v1/rent-invoices/:id/payments/intent
    15	  // -------------------------------
    16	  app.post(
    17	    "/rent-invoices/:id/payments/intent",
    18	    { preHandler: [app.authenticate] },
    19	    async (req, reply) => {
    20	      const params = z.object({ id: z.string().uuid() }).parse((req as any).params);
    21	      const body = z
    22	        .object({
    23	          paymentMethod: z.string().default("card"),
    24	          amount: z.number().optional().nullable(),
    25	          currency: z.string().optional().nullable(),
    26	        })
    27	        .default({ paymentMethod: "card" })
    28	        .parse((req as any).body ?? { paymentMethod: "card" });
    29	
    30	      const organizationId = String((req as any).orgId ?? "").trim();
    31	      const userId = String((req as any).user?.userId ?? "").trim();
    32	
    33	      if (!organizationId) {
    34	        return reply
    35	          .code(400)
    36	          .send({ ok: false, error: "ORG_REQUIRED", message: "Missing orgId from auth middleware" });
    37	      }
    38	      if (!userId) {
    39	        return reply
    40	          .code(401)
    41	          .send({ ok: false, error: "UNAUTHORIZED", message: "Missing authenticated user" });
    42	      }
    43	
    44	      const pgAny: any = (app as any).pg;
    45	      if (!pgAny?.connect) {
    46	        return reply.code(500).send({
    47	          ok: false,
    48	          error: "PG_NOT_CONFIGURED",
    49	          message: "Fastify postgres plugin not found at app.pg",
    50	        });
    51	      }
    52	
    53	      const client = await pgAny.connect();
    54	      try {
    55	        await client.query("BEGIN");
    56	
    57	        await client.query("SET LOCAL TIME ZONE 'UTC'");
    58	        // ✅ RLS context
    59	        await setPgContext(client, { userId, organizationId, role: String(req.user?.role ?? "").trim() || null, eventNote: "payments" });
    60	const intent = await createRentInvoicePaymentIntent(client, {
    61	          organizationId,
    62	          invoiceId: params.id,
    63	          paymentMethod: body.paymentMethod,
    64	          amount: body.amount ?? null,
    65	          currency: body.currency ?? null,
    66	        });
    67	
    68	        await client.query("COMMIT");
    69	        return reply.send({ ok: true, data: intent });
    70	      } catch (err: any) {
    71	        try {
    72	          await client.query("ROLLBACK");
    73	        } catch {}
    74	        return reply.code(400).send({
    75	          ok: false,
    76	          error: err?.code ?? "BAD_REQUEST",
    77	          message: err?.message ?? String(err),
    78	        });
    79	      } finally {
    80	        client.release();
    81	      }
    82	    }
    83	  );
    84	
    85	  // ---------------------------------------------------------
    86	  // OPTIONAL: Manual finalize endpoint (AUTH)
    87	  // Use only for debugging when webhook isn't firing yet.
    88	  // POST /v1/payments/paystack/finalize
    89	  // body: { transactionReference, gatewayTransactionId?, gatewayResponse? }
    90	  // ---------------------------------------------------------
    91	  app.get("/paystack/finalize",
    92	    { preHandler: [app.authenticate] },
    93	    async (req, reply) => {
    94	      const body = z
    95	        .object({
    96	          transactionReference: z.string().min(5),

---- CONTEXT around line 91 (showing 83..171) ----
    83	  );
    84	
    85	  // ---------------------------------------------------------
    86	  // OPTIONAL: Manual finalize endpoint (AUTH)
    87	  // Use only for debugging when webhook isn't firing yet.
    88	  // POST /v1/payments/paystack/finalize
    89	  // body: { transactionReference, gatewayTransactionId?, gatewayResponse? }
    90	  // ---------------------------------------------------------
    91	  app.get("/paystack/finalize",
    92	    { preHandler: [app.authenticate] },
    93	    async (req, reply) => {
    94	      const body = z
    95	        .object({
    96	          transactionReference: z.string().min(5),
    97	          gatewayTransactionId: z.string().optional().nullable(),
    98	          gatewayResponse: z.any().optional(),
    99	        })
   100	        .parse((req as any).body);
   101	
   102	      const organizationId = String((req as any).orgId ?? "").trim();
   103	      const userId = String((req as any).user?.userId ?? "").trim();
   104	
   105	      if (!organizationId) {
   106	        return reply
   107	          .code(400)
   108	          .send({ ok: false, error: "ORG_REQUIRED", message: "Missing orgId from auth middleware" });
   109	      }
   110	      if (!userId) {
   111	        return reply
   112	          .code(401)
   113	          .send({ ok: false, error: "UNAUTHORIZED", message: "Missing authenticated user" });
   114	      }
   115	
   116	      const pgAny: any = (app as any).pg;
   117	      const client = await pgAny.connect();
   118	
   119	      try {
   120	        await client.query("BEGIN");
   121	
   122	        // ✅ RLS context
   123	        await setPgContext(client, { userId, organizationId, role: String(req.user?.role ?? "").trim() || null, eventNote: "payments" });
   124	const res = await finalizePaystackSuccessForRentInvoice(client, {
   125	          transactionReference: body.transactionReference,
   126	          gatewayTransactionId: body.gatewayTransactionId ?? null,
   127	          gatewayResponse: body.gatewayResponse ?? null,
   128	        });
   129	
   130	        await client.query("COMMIT");
   131	        return reply.send({ ok: true, data: res });
   132	      } catch (err: any) {
   133	        try {
   134	          await client.query("ROLLBACK");
   135	        } catch {}
   136	        return reply.code(400).send({
   137	          ok: false,
   138	          error: err?.code ?? "BAD_REQUEST",
   139	          message: err?.message ?? String(err),
   140	        });
   141	      } finally {
   142	        client.release();
   143	      }
   144	    }
   145	  );
   146	}

============================================================
FILE: src/routes/properties.ts
------------------------------------------------------------

---- CONTEXT around line 30 (showing 22..110) ----
    22	  if (!userId) throw new Error("Missing authenticated user id (req.user.userId)");
    23	  if (!organizationId) throw new Error("Missing resolved organization id (req.orgId)");
    24	
    25	  return { userId, organizationId, role };
    26	}
    27	
    28	export async function propertyRoutes(app: FastifyInstance) {
    29	  // CREATE  ✅ POST /v1/properties
    30	  app.post(
    31	    "/",
    32	    { preHandler: [app.authenticate] },
    33	    async (req: any, reply) => {
    34	      const parsed = createPropertySchema.safeParse(req.body);
    35	      if (!parsed.success) {
    36	        return reply.code(400).send({
    37	          ok: false,
    38	          error: "VALIDATION_ERROR",
    39	          issues: parsed.error.flatten(),
    40	        });
    41	      }
    42	
    43	      const ctx = getCtx(req);
    44	
    45	      const row = await createPropertyForOrg({
    46	        userId: ctx.userId,
    47	        organizationId: ctx.organizationId,
    48	        input: parsed.data,
    49	      });
    50	
    51	      return reply.code(201).send({ ok: true, data: row });
    52	    }
    53	  );
    54	
    55	  // LIST ✅ GET /v1/properties?limit=&offset=
    56	  app.get(
    57	    "/",
    58	    { preHandler: [app.authenticate] },
    59	    async (req: any, reply) => {
    60	      const parsed = listPropertiesQuerySchema.safeParse(req.query);
    61	      if (!parsed.success) {
    62	        return reply.code(400).send({
    63	          ok: false,
    64	          error: "VALIDATION_ERROR",
    65	          issues: parsed.error.flatten(),
    66	        });
    67	      }
    68	
    69	      const ctx = getCtx(req);
    70	
    71	      const rows = await listPropertiesForOrg({
    72	        userId: ctx.userId,
    73	        organizationId: ctx.organizationId,
    74	        query: parsed.data,
    75	      });
    76	
    77	      return {
    78	        ok: true,
    79	        data: rows,
    80	        paging: { limit: parsed.data.limit, offset: parsed.data.offset },
    81	      };
    82	    }
    83	  );
    84	
    85	  // GET BY ID ✅ GET /v1/properties/:id
    86	  app.get(
    87	    "/:id",
    88	    { preHandler: [app.authenticate] },
    89	    async (req: any, reply) => {
    90	      const id = String((req.params as any).id ?? "").trim();
    91	      if (!id) {
    92	        return reply.code(400).send({ ok: false, error: "BAD_REQUEST", message: "Missing :id" });
    93	      }
    94	
    95	      const ctx = getCtx(req);
    96	
    97	      const row = await getPropertyForOrg({
    98	        userId: ctx.userId,
    99	        organizationId: ctx.organizationId,
   100	        propertyId: id,
   101	      });
   102	
   103	      if (!row) {
   104	        return reply
   105	          .code(404)
   106	          .send({ ok: false, error: "NOT_FOUND", message: "Property not found" });
   107	      }
   108	
   109	      return { ok: true, data: row };
   110	    }

---- CONTEXT around line 56 (showing 48..136) ----
    48	        input: parsed.data,
    49	      });
    50	
    51	      return reply.code(201).send({ ok: true, data: row });
    52	    }
    53	  );
    54	
    55	  // LIST ✅ GET /v1/properties?limit=&offset=
    56	  app.get(
    57	    "/",
    58	    { preHandler: [app.authenticate] },
    59	    async (req: any, reply) => {
    60	      const parsed = listPropertiesQuerySchema.safeParse(req.query);
    61	      if (!parsed.success) {
    62	        return reply.code(400).send({
    63	          ok: false,
    64	          error: "VALIDATION_ERROR",
    65	          issues: parsed.error.flatten(),
    66	        });
    67	      }
    68	
    69	      const ctx = getCtx(req);
    70	
    71	      const rows = await listPropertiesForOrg({
    72	        userId: ctx.userId,
    73	        organizationId: ctx.organizationId,
    74	        query: parsed.data,
    75	      });
    76	
    77	      return {
    78	        ok: true,
    79	        data: rows,
    80	        paging: { limit: parsed.data.limit, offset: parsed.data.offset },
    81	      };
    82	    }
    83	  );
    84	
    85	  // GET BY ID ✅ GET /v1/properties/:id
    86	  app.get(
    87	    "/:id",
    88	    { preHandler: [app.authenticate] },
    89	    async (req: any, reply) => {
    90	      const id = String((req.params as any).id ?? "").trim();
    91	      if (!id) {
    92	        return reply.code(400).send({ ok: false, error: "BAD_REQUEST", message: "Missing :id" });
    93	      }
    94	
    95	      const ctx = getCtx(req);
    96	
    97	      const row = await getPropertyForOrg({
    98	        userId: ctx.userId,
    99	        organizationId: ctx.organizationId,
   100	        propertyId: id,
   101	      });
   102	
   103	      if (!row) {
   104	        return reply
   105	          .code(404)
   106	          .send({ ok: false, error: "NOT_FOUND", message: "Property not found" });
   107	      }
   108	
   109	      return { ok: true, data: row };
   110	    }
   111	  );
   112	
   113	  // PATCH ✅ PATCH /v1/properties/:id
   114	  app.patch(
   115	    "/:id",
   116	    { preHandler: [app.authenticate] },
   117	    async (req: any, reply) => {
   118	      const id = String((req.params as any).id ?? "").trim();
   119	      if (!id) {
   120	        return reply.code(400).send({ ok: false, error: "BAD_REQUEST", message: "Missing :id" });
   121	      }
   122	
   123	      const parsed = patchPropertySchema.safeParse(req.body);
   124	      if (!parsed.success) {
   125	        return reply.code(400).send({
   126	          ok: false,
   127	          error: "VALIDATION_ERROR",
   128	          issues: parsed.error.flatten(),
   129	        });
   130	      }
   131	
   132	      const ctx = getCtx(req);
   133	
   134	      const row = await patchPropertyForOrg({
   135	        userId: ctx.userId,
   136	        organizationId: ctx.organizationId,

---- CONTEXT around line 86 (showing 78..166) ----
    78	        ok: true,
    79	        data: rows,
    80	        paging: { limit: parsed.data.limit, offset: parsed.data.offset },
    81	      };
    82	    }
    83	  );
    84	
    85	  // GET BY ID ✅ GET /v1/properties/:id
    86	  app.get(
    87	    "/:id",
    88	    { preHandler: [app.authenticate] },
    89	    async (req: any, reply) => {
    90	      const id = String((req.params as any).id ?? "").trim();
    91	      if (!id) {
    92	        return reply.code(400).send({ ok: false, error: "BAD_REQUEST", message: "Missing :id" });
    93	      }
    94	
    95	      const ctx = getCtx(req);
    96	
    97	      const row = await getPropertyForOrg({
    98	        userId: ctx.userId,
    99	        organizationId: ctx.organizationId,
   100	        propertyId: id,
   101	      });
   102	
   103	      if (!row) {
   104	        return reply
   105	          .code(404)
   106	          .send({ ok: false, error: "NOT_FOUND", message: "Property not found" });
   107	      }
   108	
   109	      return { ok: true, data: row };
   110	    }
   111	  );
   112	
   113	  // PATCH ✅ PATCH /v1/properties/:id
   114	  app.patch(
   115	    "/:id",
   116	    { preHandler: [app.authenticate] },
   117	    async (req: any, reply) => {
   118	      const id = String((req.params as any).id ?? "").trim();
   119	      if (!id) {
   120	        return reply.code(400).send({ ok: false, error: "BAD_REQUEST", message: "Missing :id" });
   121	      }
   122	
   123	      const parsed = patchPropertySchema.safeParse(req.body);
   124	      if (!parsed.success) {
   125	        return reply.code(400).send({
   126	          ok: false,
   127	          error: "VALIDATION_ERROR",
   128	          issues: parsed.error.flatten(),
   129	        });
   130	      }
   131	
   132	      const ctx = getCtx(req);
   133	
   134	      const row = await patchPropertyForOrg({
   135	        userId: ctx.userId,
   136	        organizationId: ctx.organizationId,
   137	        propertyId: id,
   138	        patch: parsed.data,
   139	      });
   140	
   141	      if (!row) {
   142	        return reply
   143	          .code(404)
   144	          .send({ ok: false, error: "NOT_FOUND", message: "Property not found" });
   145	      }
   146	
   147	      return { ok: true, data: row };
   148	    }
   149	  );
   150	}
---- CONTEXT around line 114 (showing 106..194) ----
   106	          .send({ ok: false, error: "NOT_FOUND", message: "Property not found" });
   107	      }
   108	
   109	      return { ok: true, data: row };
   110	    }
   111	  );
   112	
   113	  // PATCH ✅ PATCH /v1/properties/:id
   114	  app.patch(
   115	    "/:id",
   116	    { preHandler: [app.authenticate] },
   117	    async (req: any, reply) => {
   118	      const id = String((req.params as any).id ?? "").trim();
   119	      if (!id) {
   120	        return reply.code(400).send({ ok: false, error: "BAD_REQUEST", message: "Missing :id" });
   121	      }
   122	
   123	      const parsed = patchPropertySchema.safeParse(req.body);
   124	      if (!parsed.success) {
   125	        return reply.code(400).send({
   126	          ok: false,
   127	          error: "VALIDATION_ERROR",
   128	          issues: parsed.error.flatten(),
   129	        });
   130	      }
   131	
   132	      const ctx = getCtx(req);
   133	
   134	      const row = await patchPropertyForOrg({
   135	        userId: ctx.userId,
   136	        organizationId: ctx.organizationId,
   137	        propertyId: id,
   138	        patch: parsed.data,
   139	      });
   140	
   141	      if (!row) {
   142	        return reply
   143	          .code(404)
   144	          .send({ ok: false, error: "NOT_FOUND", message: "Property not found" });
   145	      }
   146	
   147	      return { ok: true, data: row };
   148	    }
   149	  );
   150	}
============================================================
FILE: src/routes/purchase_close.ts
------------------------------------------------------------

---- CONTEXT around line 24 (showing 16..104) ----
    16	      request.sub ||
    17	      request.user?.sub ||
    18	      ""
    19	  ).trim();
    20	}
    21	
    22	export async function purchaseCloseRoutes(app: FastifyInstance) {
    23	  // POST /v1/purchases/:id/close
    24	  app.post(
    25	    "/:id/close",
    26	    { preHandler: [app.authenticate] },
    27	    async (request, reply) => {
    28	      const purchaseId = String((request.params as any)?.id || "").trim();
    29	      if (!purchaseId) {
    30	        return reply.code(400).send({ ok: false, error: "PURCHASE_ID_REQUIRED" });
    31	      }
    32	
    33	      const orgId = getOrgId(request);
    34	      if (!orgId) {
    35	        return reply.code(400).send({ ok: false, error: "ORG_REQUIRED" });
    36	      }
    37	
    38	      const actorId = getActorId(request);
    39	      if (!actorId) {
    40	        return reply.code(401).send({ ok: false, error: "AUTH_REQUIRED", message: "Missing actor id from auth" });
    41	      }
    42	
    43	      const body = (request.body || {}) as CloseBody;
    44	      const note = typeof body.note === "string" ? body.note.trim() : null;
    45	
    46	      const client = await app.pg.connect();
    47	      try {
    48	        await setPgContext(client, {
    49	          organizationId: orgId,
    50	          userId: actorId, // for RLS context
    51	          role: (request as any).role || null,
    52	        });
    53	
    54	        // IMPORTANT: pass actorId as arg #3 so safe_audit_log writes changed_by
    55	        const { rows } = await client.query(
    56	          `select public.purchase_close_complete($1::uuid, $2::uuid, $3::uuid, $4::text) as result`,
    57	          [purchaseId, orgId, actorId, note]
    58	        );
    59	
    60	        const result = rows?.[0]?.result ?? null;
    61	        if (result && result.ok === false) {
    62	          return reply.code(400).send({
    63	            ok: false,
    64	            error: result.error || "CLOSE_FAILED",
    65	            message: result.message || "",
    66	          });
    67	        }
    68	
    69	        return reply.send({ ok: true, data: result || { ok: true } });
    70	      } catch (e: any) {
    71	        request.log.error(e);
    72	        return reply.code(400).send({ ok: false, error: "CLOSE_FAILED", message: e?.message || String(e) });
    73	      } finally {
    74	        client.release();
    75	      }
    76	    }
    77	  );
    78	}

============================================================
FILE: src/routes/purchase_escrow.ts
------------------------------------------------------------

---- CONTEXT around line 15 (showing 7..95) ----
     7	export async function purchaseEscrowRoutes(app: FastifyInstance) {
     8	  // POST /v1/purchases/:id/release-escrow
     9	  // Auth required
    10	  //
    11	  // IMPORTANT:
    12	  // This route accepts BOTH:
    13	  // - no JSON body at all
    14	  // - or { "note": "..." }
    15	  app.get("/:id/release-escrow",
    16	    { preHandler: [app.authenticate] },
    17	    async (req, reply) => {
    18	      const params = z.object({ id: z.string().uuid() }).parse((req as any).params);
    19	
    20	      // Body is OPTIONAL (fix for "Body cannot be empty when content-type is application/json")
    21	      const body = z
    22	        .object({
    23	          note: z.string().min(1).optional(),
    24	        })
    25	        .optional()
    26	        .parse((req as any).body);
    27	
    28	      const organizationId = String((req as any).orgId ?? "").trim();
    29	      const userId = String((req as any).user?.userId ?? "").trim();
    30	
    31	      if (!organizationId) {
    32	        return reply
    33	          .code(400)
    34	          .send({ ok: false, error: "ORG_REQUIRED", message: "Missing orgId from auth middleware" });
    35	      }
    36	      if (!userId) {
    37	        return reply
    38	          .code(401)
    39	          .send({ ok: false, error: "UNAUTHORIZED", message: "Missing authenticated user" });
    40	      }
    41	
    42	      // @ts-ignore - fastify-postgres decorates app.pg
    43	      const client = await app.pg.connect();
    44	      try {
    45	        await client.query("BEGIN");
    46	
    47	        await client.query("SET LOCAL TIME ZONE 'UTC'");
    48	        // RLS context
    49	        await setPgContext(client, { userId, organizationId, role: String(req.user?.role ?? "").trim() || null, eventNote: "purchase_escrow" });
    50	const res = await releasePurchaseEscrow(client, {
    51	          purchaseId: params.id,
    52	          note: body?.note ?? "Closing complete, released escrow",
    53	        });
    54	
    55	        await client.query("COMMIT");
    56	
    57	        if (!res.ok) {
    58	          return reply.code(400).send({ ok: false, error: res.error, message: res.message });
    59	        }
    60	
    61	        return reply.send({ ok: true, data: res });
    62	      } catch (e: any) {
    63	        try {
    64	          await client.query("ROLLBACK");
    65	        } catch {}
    66	        return reply.code(500).send({
    67	          ok: false,
    68	          error: "SERVER_ERROR",
    69	          message: e?.message ?? String(e),
    70	        });
    71	      } finally {
    72	        client.release();
    73	      }
    74	    }
    75	  );
    76	}

============================================================
FILE: src/routes/rent_invoices.ts
------------------------------------------------------------

---- CONTEXT around line 86 (showing 78..166) ----
    78	  }
    79	  await setPgContext(client, { userId, organizationId: orgId, role, eventNote: "rent_invoices" });
    80	}
    81	
    82	export async function rentInvoicesRoutes(app: FastifyInstance) {
    83	  // ------------------------------------------------------------
    84	  // POST /tenancies/:id/rent-invoices/generate
    85	  // ------------------------------------------------------------
    86	  app.post(
    87	    "/tenancies/:id/rent-invoices/generate",
    88	    { preHandler: [app.authenticate] },
    89	    async (req, reply) => {
    90	      try {
    91	        const orgId = requireOrgId(req, reply);
    92	        const userId = requireUserId(req, reply);
    93	        if (!orgId || !userId) return;
    94	
    95	        const params = z.object({ id: z.string().uuid() }).parse((req as any).params);
    96	        const body = GenerateRentInvoiceBodySchema.parse((req as any).body);
    97	
    98	        const pgAny: any = (app as any).pg;
    99	        if (!pgAny?.connect) {
   100	          return reply.code(500).send({
   101	            ok: false,
   102	            error: "PG_NOT_CONFIGURED",
   103	            message: "Fastify pg plugin not found at app.pg",
   104	          });
   105	        }
   106	
   107	        const client = (await pgAny.connect()) as PoolClient;
   108	        try {
   109	          // Optional: refresh role from DB
   110	          const dbRole = await fetchDbRole(client, userId);
   111	          (req as any).user.role = (dbRole ?? (req as any).user.role) as any;
   112	
   113	          await applyDbContext(client, req);
   114	          await client.query("BEGIN");
   115	
   116	        await client.query("SET LOCAL TIME ZONE 'UTC'");
   117	          const res = await generateRentInvoiceForTenancy(client, {
   118	            organizationId: orgId,
   119	            tenancyId: params.id,
   120	            periodStart: body.periodStart,
   121	            periodEnd: body.periodEnd,
   122	            dueDate: body.dueDate,
   123	            subtotal: body.subtotal,
   124	            lateFeeAmount: body.lateFeeAmount,
   125	            currency: body.currency,
   126	            status: body.status,
   127	            notes: body.notes,
   128	          });
   129	
   130	          await client.query("COMMIT");
   131	          return reply.send({ ok: true, reused: res.reused, data: res.row });
   132	        } catch (err: any) {
   133	          try {
   134	            await client.query("ROLLBACK");
   135	          } catch {}
   136	          return reply.code(500).send({
   137	            ok: false,
   138	            error: err?.code ?? "INTERNAL_ERROR",
   139	            message: err?.message ?? String(err),
   140	          });
   141	        } finally {
   142	          client.release();
   143	        }
   144	      } catch (err: any) {
   145	        return reply.code(400).send({
   146	          ok: false,
   147	          error: err?.code ?? "BAD_REQUEST",
   148	          message: err?.message ?? String(err),
   149	        });
   150	      }
   151	    }
   152	  );
   153	
   154	  // ------------------------------------------------------------
   155	  // GET /rent-invoices
   156	  // ------------------------------------------------------------
   157	  app.get("/", { preHandler: [app.authenticate] }, async (req, reply) => {
   158	    try {
   159	      const orgId = requireOrgId(req, reply);
   160	      const userId = requireUserId(req, reply);
   161	      if (!orgId || !userId) return;
   162	
   163	      const q = ListRentInvoicesQuerySchema.parse((req as any).query);
   164	
   165	      const pgAny: any = (app as any).pg;
   166	      if (!pgAny?.connect) {

---- CONTEXT around line 157 (showing 149..237) ----
   149	        });
   150	      }
   151	    }
   152	  );
   153	
   154	  // ------------------------------------------------------------
   155	  // GET /rent-invoices
   156	  // ------------------------------------------------------------
   157	  app.get("/", { preHandler: [app.authenticate] }, async (req, reply) => {
   158	    try {
   159	      const orgId = requireOrgId(req, reply);
   160	      const userId = requireUserId(req, reply);
   161	      if (!orgId || !userId) return;
   162	
   163	      const q = ListRentInvoicesQuerySchema.parse((req as any).query);
   164	
   165	      const pgAny: any = (app as any).pg;
   166	      if (!pgAny?.connect) {
   167	        return reply.code(500).send({
   168	          ok: false,
   169	          error: "PG_NOT_CONFIGURED",
   170	          message: "Fastify pg plugin not found at app.pg",
   171	        });
   172	      }
   173	
   174	      const client = (await pgAny.connect()) as PoolClient;
   175	      try {
   176	        const dbRole = await fetchDbRole(client, userId);
   177	        (req as any).user.role = (dbRole ?? (req as any).user.role) as any;
   178	
   179	        await applyDbContext(client, req);
   180	
   181	        const data = await getRentInvoices(client, {
   182	          limit: q.limit,
   183	          offset: q.offset,
   184	          tenancyId: q.tenancyId,
   185	          tenantId: q.tenantId,
   186	          propertyId: q.propertyId,
   187	          status: q.status,
   188	        });
   189	
   190	        return reply.send({ ok: true, data, paging: { limit: q.limit, offset: q.offset } });
   191	      } catch (err: any) {
   192	        return reply.code(500).send({
   193	          ok: false,
   194	          error: err?.code ?? "INTERNAL_ERROR",
   195	          message: err?.message ?? String(err),
   196	        });
   197	      } finally {
   198	        client.release();
   199	      }
   200	    } catch (err: any) {
   201	      return reply.code(400).send({
   202	        ok: false,
   203	        error: err?.code ?? "BAD_REQUEST",
   204	        message: err?.message ?? String(err),
   205	      });
   206	    }
   207	  });
   208	
   209	  // ------------------------------------------------------------
   210	  // POST /rent-invoices/:id/pay (admin-only for now)
   211	  // ------------------------------------------------------------
   212	  app.get("/:id/pay", { preHandler: [app.authenticate] }, async (req, reply) => {
   213	    const orgId = requireOrgId(req, reply);
   214	    const userId = requireUserId(req, reply);
   215	    if (!orgId || !userId) return;
   216	
   217	    const pgAny: any = (app as any).pg;
   218	    if (!pgAny?.connect) {
   219	      return reply.code(500).send({
   220	        ok: false,
   221	        error: "PG_NOT_CONFIGURED",
   222	        message: "Fastify pg plugin not found at app.pg",
   223	      });
   224	    }
   225	
   226	    const params = z.object({ id: z.string().uuid() }).parse((req as any).params);
   227	    const body = PayRentInvoiceBodySchema.parse((req as any).body);
   228	
   229	    const client = (await pgAny.connect()) as PoolClient;
   230	    try {
   231	      const dbRole = await fetchDbRole(client, userId);
   232	      (req as any).user.role = (dbRole ?? (req as any).user.role) as any;
   233	
   234	      await applyDbContext(client, req);
   235	
   236	      if (dbRole !== "admin") {
   237	        return reply.code(403).send({ ok: false, error: "FORBIDDEN", message: "Admin only for now." });

---- CONTEXT around line 212 (showing 204..292) ----
   204	        message: err?.message ?? String(err),
   205	      });
   206	    }
   207	  });
   208	
   209	  // ------------------------------------------------------------
   210	  // POST /rent-invoices/:id/pay (admin-only for now)
   211	  // ------------------------------------------------------------
   212	  app.get("/:id/pay", { preHandler: [app.authenticate] }, async (req, reply) => {
   213	    const orgId = requireOrgId(req, reply);
   214	    const userId = requireUserId(req, reply);
   215	    if (!orgId || !userId) return;
   216	
   217	    const pgAny: any = (app as any).pg;
   218	    if (!pgAny?.connect) {
   219	      return reply.code(500).send({
   220	        ok: false,
   221	        error: "PG_NOT_CONFIGURED",
   222	        message: "Fastify pg plugin not found at app.pg",
   223	      });
   224	    }
   225	
   226	    const params = z.object({ id: z.string().uuid() }).parse((req as any).params);
   227	    const body = PayRentInvoiceBodySchema.parse((req as any).body);
   228	
   229	    const client = (await pgAny.connect()) as PoolClient;
   230	    try {
   231	      const dbRole = await fetchDbRole(client, userId);
   232	      (req as any).user.role = (dbRole ?? (req as any).user.role) as any;
   233	
   234	      await applyDbContext(client, req);
   235	
   236	      if (dbRole !== "admin") {
   237	        return reply.code(403).send({ ok: false, error: "FORBIDDEN", message: "Admin only for now." });
   238	      }
   239	
   240	      await client.query("BEGIN");
   241	
   242	      const res = await payRentInvoice(client, {
   243	        invoiceId: params.id,
   244	        paymentMethod: String(body.paymentMethod),
   245	        amount: body.amount ?? null,
   246	      });
   247	
   248	      await client.query("COMMIT");
   249	      return reply.send({ ok: true, alreadyPaid: res.alreadyPaid, data: res.row });
   250	    } catch (err: any) {
   251	      try {
   252	        await client.query("ROLLBACK");
   253	      } catch {}
   254	      return reply.code(500).send({
   255	        ok: false,
   256	        error: err?.code ?? "INTERNAL_ERROR",
   257	        message: err?.message ?? String(err),
   258	      });
   259	    } finally {
   260	      client.release();
   261	    }
   262	  });
   263	}

============================================================
FILE: src/routes/viewings.ts
------------------------------------------------------------

---- CONTEXT around line 17 (showing 9..97) ----
     9	function getCtx(req: any) {
    10	  const userId = String(req?.user?.userId ?? "").trim();
    11	  const organizationId = String(req?.orgId ?? "").trim();
    12	  const role = (req?.user?.role ?? null) as any;
    13	  return { userId, organizationId, role };
    14	}
    15	
    16	export async function viewingRoutes(app: FastifyInstance) {
    17	  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
    18	    const q = listViewingsQuerySchema.parse(req.query ?? {});
    19	    const ctx = getCtx(req);
    20	
    21	    const data = await withRlsTransaction(
    22	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: "viewings:list" },
    23	      async (client: PoolClient) => {
    24	        return listAllViewings(client, {
    25	          limit: q.limit,
    26	          offset: q.offset,
    27	          listing_id: q.listingId,
    28	          property_id: q.propertyId,
    29	          tenant_id: q.tenantId,
    30	          status: q.status ?? undefined,
    31	        });
    32	      }
    33	    );
    34	
    35	    return { ok: true, data, paging: { limit: q.limit, offset: q.offset } };
    36	  });
    37	
    38	  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
    39	    const { id } = req.params as any;
    40	    const ctx = getCtx(req);
    41	
    42	    const data = await withRlsTransaction(
    43	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `viewings:get:${String(id)}` },
    44	      async (client: PoolClient) => {
    45	        return getViewing(client, String(id));
    46	      }
    47	    );
    48	
    49	    return { ok: true, data };
    50	  });
    51	
    52	  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
    53	    const body = createViewingBodySchema.parse(req.body ?? {});
    54	    const ctx = getCtx(req);
    55	
    56	    const allowStatus = req.user?.role === "admin";
    57	    const status = allowStatus ? (body.status ?? undefined) : undefined;
    58	
    59	    const data = await withRlsTransaction(
    60	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: "viewings:create" },
    61	      async (client: PoolClient) => {
    62	        return createViewing(
    63	          client,
    64	          { userId: ctx.userId },
    65	          {
    66	            listing_id: body.listingId,
    67	            property_id: body.propertyId,
    68	            scheduled_at: body.scheduledAt,
    69	            view_mode: body.viewMode ?? undefined,
    70	            notes: body.notes ?? null,
    71	            status,
    72	          }
    73	        );
    74	      }
    75	    );
    76	
    77	    return { ok: true, data };
    78	  });
    79	
    80	  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
    81	    const { id } = req.params as any;
    82	    const body = patchViewingBodySchema.parse(req.body ?? {});
    83	    const ctx = getCtx(req);
    84	
    85	    const patch: any = {};
    86	    if (body.scheduledAt !== undefined) patch.scheduled_at = body.scheduledAt;
    87	    if (body.viewMode !== undefined) patch.view_mode = body.viewMode;
    88	    if (body.notes !== undefined) patch.notes = body.notes;
    89	
    90	    if (body.status !== undefined) {
    91	      if (req.user?.role !== "admin") return { ok: false, error: "FORBIDDEN", message: "Only admin can change viewing status." };
    92	      patch.status = body.status;
    93	    }
    94	
    95	    const data = await withRlsTransaction(
    96	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `viewings:patch:${String(id)}` },
    97	      async (client: PoolClient) => {

---- CONTEXT around line 38 (showing 30..118) ----
    30	          status: q.status ?? undefined,
    31	        });
    32	      }
    33	    );
    34	
    35	    return { ok: true, data, paging: { limit: q.limit, offset: q.offset } };
    36	  });
    37	
    38	  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
    39	    const { id } = req.params as any;
    40	    const ctx = getCtx(req);
    41	
    42	    const data = await withRlsTransaction(
    43	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `viewings:get:${String(id)}` },
    44	      async (client: PoolClient) => {
    45	        return getViewing(client, String(id));
    46	      }
    47	    );
    48	
    49	    return { ok: true, data };
    50	  });
    51	
    52	  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
    53	    const body = createViewingBodySchema.parse(req.body ?? {});
    54	    const ctx = getCtx(req);
    55	
    56	    const allowStatus = req.user?.role === "admin";
    57	    const status = allowStatus ? (body.status ?? undefined) : undefined;
    58	
    59	    const data = await withRlsTransaction(
    60	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: "viewings:create" },
    61	      async (client: PoolClient) => {
    62	        return createViewing(
    63	          client,
    64	          { userId: ctx.userId },
    65	          {
    66	            listing_id: body.listingId,
    67	            property_id: body.propertyId,
    68	            scheduled_at: body.scheduledAt,
    69	            view_mode: body.viewMode ?? undefined,
    70	            notes: body.notes ?? null,
    71	            status,
    72	          }
    73	        );
    74	      }
    75	    );
    76	
    77	    return { ok: true, data };
    78	  });
    79	
    80	  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
    81	    const { id } = req.params as any;
    82	    const body = patchViewingBodySchema.parse(req.body ?? {});
    83	    const ctx = getCtx(req);
    84	
    85	    const patch: any = {};
    86	    if (body.scheduledAt !== undefined) patch.scheduled_at = body.scheduledAt;
    87	    if (body.viewMode !== undefined) patch.view_mode = body.viewMode;
    88	    if (body.notes !== undefined) patch.notes = body.notes;
    89	
    90	    if (body.status !== undefined) {
    91	      if (req.user?.role !== "admin") return { ok: false, error: "FORBIDDEN", message: "Only admin can change viewing status." };
    92	      patch.status = body.status;
    93	    }
    94	
    95	    const data = await withRlsTransaction(
    96	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `viewings:patch:${String(id)}` },
    97	      async (client: PoolClient) => {
    98	        return updateViewing(client, String(id), patch);
    99	      }
   100	    );
   101	
   102	    return { ok: true, data };
   103	  });
   104	}

---- CONTEXT around line 52 (showing 44..132) ----
    44	      async (client: PoolClient) => {
    45	        return getViewing(client, String(id));
    46	      }
    47	    );
    48	
    49	    return { ok: true, data };
    50	  });
    51	
    52	  app.get("/", { preHandler: [app.authenticate] }, async (req: any) => {
    53	    const body = createViewingBodySchema.parse(req.body ?? {});
    54	    const ctx = getCtx(req);
    55	
    56	    const allowStatus = req.user?.role === "admin";
    57	    const status = allowStatus ? (body.status ?? undefined) : undefined;
    58	
    59	    const data = await withRlsTransaction(
    60	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: "viewings:create" },
    61	      async (client: PoolClient) => {
    62	        return createViewing(
    63	          client,
    64	          { userId: ctx.userId },
    65	          {
    66	            listing_id: body.listingId,
    67	            property_id: body.propertyId,
    68	            scheduled_at: body.scheduledAt,
    69	            view_mode: body.viewMode ?? undefined,
    70	            notes: body.notes ?? null,
    71	            status,
    72	          }
    73	        );
    74	      }
    75	    );
    76	
    77	    return { ok: true, data };
    78	  });
    79	
    80	  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
    81	    const { id } = req.params as any;
    82	    const body = patchViewingBodySchema.parse(req.body ?? {});
    83	    const ctx = getCtx(req);
    84	
    85	    const patch: any = {};
    86	    if (body.scheduledAt !== undefined) patch.scheduled_at = body.scheduledAt;
    87	    if (body.viewMode !== undefined) patch.view_mode = body.viewMode;
    88	    if (body.notes !== undefined) patch.notes = body.notes;
    89	
    90	    if (body.status !== undefined) {
    91	      if (req.user?.role !== "admin") return { ok: false, error: "FORBIDDEN", message: "Only admin can change viewing status." };
    92	      patch.status = body.status;
    93	    }
    94	
    95	    const data = await withRlsTransaction(
    96	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `viewings:patch:${String(id)}` },
    97	      async (client: PoolClient) => {
    98	        return updateViewing(client, String(id), patch);
    99	      }
   100	    );
   101	
   102	    return { ok: true, data };
   103	  });
   104	}

---- CONTEXT around line 80 (showing 72..160) ----
    72	          }
    73	        );
    74	      }
    75	    );
    76	
    77	    return { ok: true, data };
    78	  });
    79	
    80	  app.get("/:id", { preHandler: [app.authenticate] }, async (req: any) => {
    81	    const { id } = req.params as any;
    82	    const body = patchViewingBodySchema.parse(req.body ?? {});
    83	    const ctx = getCtx(req);
    84	
    85	    const patch: any = {};
    86	    if (body.scheduledAt !== undefined) patch.scheduled_at = body.scheduledAt;
    87	    if (body.viewMode !== undefined) patch.view_mode = body.viewMode;
    88	    if (body.notes !== undefined) patch.notes = body.notes;
    89	
    90	    if (body.status !== undefined) {
    91	      if (req.user?.role !== "admin") return { ok: false, error: "FORBIDDEN", message: "Only admin can change viewing status." };
    92	      patch.status = body.status;
    93	    }
    94	
    95	    const data = await withRlsTransaction(
    96	      { userId: ctx.userId, organizationId: ctx.organizationId, role: ctx.role, eventNote: `viewings:patch:${String(id)}` },
    97	      async (client: PoolClient) => {
    98	        return updateViewing(client, String(id), patch);
    99	      }
   100	    );
   101	
   102	    return { ok: true, data };
   103	  });
   104	}

============================================================
FILE: src/routes/webhooks.ts
------------------------------------------------------------

---- CONTEXT around line 145 (showing 137..225) ----
   137	  return {
   138	    organizationId: String(row.organization_id).trim(),
   139	    actorUserId: row.actor_user_id ? String(row.actor_user_id).trim() : null,
   140	    reference,
   141	  };
   142	}
   143	
   144	export async function webhooksRoutes(app: FastifyInstance) {
   145	  app.post(
   146	    "/webhooks/paystack",
   147	    {
   148	      // if fastify-raw-body is registered, this will attach request.rawBody
   149	      config: { rawBody: true },
   150	    },
   151	    async (request, reply) => {
   152	      const secret = String(paymentConfig.paystack.webhookSecret ?? "").trim();
   153	      if (!secret) {
   154	        return reply.code(500).send({ ok: false, error: "WEBHOOK_SECRET_MISSING" });
   155	      }
   156	
   157	      const sigHeaderRaw = String(request.headers["x-paystack-signature"] ?? "").trim();
   158	      if (!sigHeaderRaw) {
   159	        return reply.code(400).send({ ok: false, error: "SIGNATURE_MISSING" });
   160	      }
   161	
   162	      const signature = normalizeSig(sigHeaderRaw);
   163	      if (!/^[0-9a-f]{128}$/.test(signature)) {
   164	        return reply.code(400).send({ ok: false, error: "SIGNATURE_INVALID_FORMAT" });
   165	      }
   166	
   167	      // ---- A) Hash JSON.stringify(body) ----
   168	      const bodyObj: any = (request as any).body ?? {};
   169	      const bodyString = JSON.stringify(bodyObj);
   170	
   171	      const jsonHashHex = crypto
   172	        .createHmac("sha512", secret)
   173	        .update(bodyString)
   174	        .digest("hex")
   175	        .toLowerCase();
   176	
   177	      let ok = safeTimingEqualHex(signature, jsonHashHex);
   178	
   179	      // ---- B) If JSON hash fails, try raw body hash (if available) ----
   180	      let rawHashHex: string | null = null;
   181	      const rawAny = (request as any).rawBody as Buffer | string | undefined;
   182	
   183	      let rawBuf: Buffer | null = null;
   184	      if (Buffer.isBuffer(rawAny)) rawBuf = rawAny;
   185	      else if (typeof rawAny === "string") rawBuf = Buffer.from(rawAny, "utf8");
   186	
   187	      if (!ok && rawBuf && rawBuf.length > 0) {
   188	        rawHashHex = crypto
   189	          .createHmac("sha512", secret)
   190	          .update(rawBuf)
   191	          .digest("hex")
   192	          .toLowerCase();
   193	
   194	        ok = safeTimingEqualHex(signature, rawHashHex);
   195	      }
   196	
   197	      if (!ok) {
   198	        // SAFE DEBUG — no secret value exposed
   199	        const debug = {
   200	          secretLen: secret.length,
   201	          secretPrefix: secret.slice(0, 6),
   202	          secretSuffix: secret.slice(-4),
   203	
   204	          signaturePrefix: signature.slice(0, 16),
   205	          signatureSuffix: signature.slice(-16),
   206	
   207	          jsonHashPrefix: jsonHashHex.slice(0, 16),
   208	          jsonHashSuffix: jsonHashHex.slice(-16),
   209	
   210	          rawHashPrefix: rawHashHex ? rawHashHex.slice(0, 16) : null,
   211	          rawHashSuffix: rawHashHex ? rawHashHex.slice(-16) : null,
   212	
   213	          bodyStringLen: bodyString.length,
   214	          rawBodyType: rawAny == null ? null : Buffer.isBuffer(rawAny) ? "buffer" : typeof rawAny,
   215	          rawLen: rawBuf ? rawBuf.length : 0,
   216	        };
   217	
   218	        app.log.warn(debug, "paystack signature mismatch");
   219	
   220	        const isProd = String(process.env.NODE_ENV || "").toLowerCase() === "production";
   221	        return reply
   222	          .code(401)
   223	          .send(isProd ? { ok: false, error: "INVALID_SIGNATURE" } : { ok: false, error: "INVALID_SIGNATURE", debug });
   224	      }
   225	

================ BROKEN QUOTE CHECK ========================
✅ No obvious app.<verb>("<newline> broken quotes

============================================================
✅ Saved to: routes_full_dump_20260118_164709.txt
Now paste the terminal output OR run: cat routes_full_dump_20260118_164709.txt
============================================================
